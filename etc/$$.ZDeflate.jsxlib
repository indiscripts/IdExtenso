/*******************************************************************************

		Name:           ZDeflate
		Desc:           DEFLATE/ZIP/GZIP/ZLIB Compressors
		Path:           /etc/$$.ZDeflate.jsxlib
		Require:        ---
		Encoding:       ÛȚF8
		Core:           NO
		Kind:           Module.
		API:            =raw() zip() gzip() zlib()
		                ForceInternal
		DOM-access:     app.packageUCF() [usually required]
		Todo:           ---
		Created:        180914 (YYMMDD)
		Modified:       260205 (YYMMDD)

*******************************************************************************/

#include 'ZDeflateInflate/$$.BitWriter.jsxlib'

;$$.hasOwnProperty('ZDeflate') || eval(__(MODULE, $$, 'ZDeflate', 260205, 'raw'))

	//==========================================================================
	// NOTICE
	//==========================================================================

	/*
		[CHG260205] Refactored from scratch.

		PURPOSE
		________________________________________________________________________

		The ZDeflate module implements DEFLATE/ZIP/GZIP/ZLIB compression
		with LZ77-like matching and Huffman encoding. It provides both fast raw
		DEFLATE compression and/or complete archive support through InDesign's
		app.packageUCF() when available¹.

		¹ Automatic fallback strategy: Uses app.packageUCF() for files > 2KB
		  (much faster) and falls back to pure ExtendScript (~.RCMP) for
		  smaller inputs or when app.packageUCF() is unavailable.

		ZDeflate internally supports dual compression modes (Static vs. Dynamic
		Huffman trees) and 'mimicks' LZ77 through binary-search prefix matching
		with configurable match length (3..258) and distance (3..16384). A fast
		package-merge algorithm is used (optimized for ExtendScript) with length-
		limited Huffman code generation up to 15 bits. These options are not
		exposed to the API: the default parameters work fine (dynamic mode,
		max_match_length:10, max_distance:4096).

		ZDeflate supports the following formats: Raw DEFLATE² (default), ZIP³,
		GZIP, ZLIB wrappers with proper CRC32/ADLER32 checksums.

		² The raw compressor (RCMP) handles up to 1MB via automatic 64KB block
		  segmentation, so you can still compress (deflate) reasonably sized
		  streams even if packageUCF() doesn't respond. This internal utility
		  should handle 100K streams in about 1s.

		³ The zip() method manages UTF-8 filename. It automatically encodes
		  non-ASCII filenames in ZIP archives using UTF-8 flag (0x800) when
		  necessary -- an issue that app.packageUCF() doesn't seem to
		  natively address.

		The client script is expected to send bytes (int8). All public methods
		accept strings (bytes as charcodes), arrays or File objects. When you
		pass a string -- which is definitely the best format in ExtendScript --
		make sure it is not, or no longer, made of UTF16 units (all compressors
		assume byte-level processing).

		In particular, an arbitrary *text* string is not a byte stream per se,
		unless it is known to contain pure ASCII characters. Otherwise, it's
		your responsibility to 'translate' a text into bytes. The most common
		inter-format is UTF8, i.e. `myString.toUTF8()` in IdExtenso.

		Compressors are more likely to be invoked within file format processing
		tasks (PNG chunks, etc).


		IMPLEMENTATION NOTES
		________________________________________________________________________

		Our custom LZ77 algorithm (PRFX) only handle {length,distance} pairs
		that can be encoded in a single UTF16 token using the format:

		               1(DD..DD)(LL..LL)   16 bits
		               │└──┬───┘└──┬───┘
		               │   │       └────── Length - 3
		               │   └────────────── Distance - 1
		               └─ Flag

		where the sequence (DD..DD)(LL..LL) uses exactly 15 bits. The 16-bit
		mask (0x8000) determines whether a token represents a {length,distance}
		pair. Other char codes transparently represent incoming bytes left intact
		during compression.

		The respective bitlength of (DD..DD) vs. (LL..LL) is determined dynamically
		with respect to internal options bounded by these absolute min/max ranges:

		     ABSOLUTE              ZDeflate      DEFLATE
		      BOUNDARY             Support*      Spec.
		     ------------------------------------------------
		     Min. Match Length      3             3
		     Max. Match Length      258           258
		     Max. Match Distance    16384         32768
		     ------------------------------------------------
		     * ZDeflate also limits to 15 bits the internal
		       representation of maxLen|maxDis, which makes
		       these two maxima interdependent.

		Internal Encoding and Ranges:
		  ---------------------------------------------------
		   CATEGORY | RAW VALUE |  TOKEN CHARCODE  |  SYMBOL
		  ---------------------------------------------------
		  Literals  |  0-255    |    RAW VALUE     |   0-255   LL
		  EOB       |   ---     |       ---        |    256    LL
		  Lengths   |  3-255    |  1...(LL..LL)¹   | 257-285³  LL
		  Distances |  1-16384  |  1(DD..DD)...²   |   0-29⁴   DS
		  ---------------------------------------------------
		   ¹  (LL..LL) is the binary LOW part of the {L,D}
		      token (see above.)
		   ²  (DD..DD) is the binary HIGH part of the {L,D}
		      token (see above.)
		   ³  Symbols come from ~.L2SY (3..258)=>(257..285).
		      The static LL map also include the symbols 286,287
		      (specified but not used.)
		   ⁴  Symbols comes from ~.D2SY (1..16384)=>(0..29)
		      Symbols 30,31 exist in the alphabet but “will never
		      actually occur”.

		In practice, we found that pre-setting max_length = 10
		and max_dist = 4096 still results in very decent compression
		ratio (~40%) in optimal time, at least with random ‘lorem-
		ipsum’ ASCII streams.
		
		If you want to play with other options, make your client
		code refine the private `µ['~'].RCMP.OPS` object. Just
		be sure that the resulting `(DD..DD)(LL..LL)` encoding
		won't require more than 15 bits.
		
		Finally, remember that the internal compressor and all its
		dependencies are completely bypassed for streams > 2K if
		`app.packageUCF` is available, which is usually the case
		in an InDesign script. Set the `ForceInternal` property
		to 1 if you want to forcibly disable this 'external' tool.

	*/

	//==========================================================================
	// COMMON ZInflate/ZDeflate TOOLS
	//==========================================================================

	#include 'ZDeflateInflate/$$.common.jsxinc'

	//==========================================================================
	// CANONICAL HUFFMAN CODE MAPS (STATIC) & SYMBOLS
	// LLMP  DSMP  L2SY  D2SY()
	//==========================================================================

	[PRIVATE]

	({

		// Static LITERAL/LENGTH Map :: 0..287 => binstr (7 to 9 bit chars)
		//----------------------------------
		LLMP:
		{
			// DEFLATE spec:     LL SYMBOL  CL(bits)
			//                   ------------------
			//                    0-143     8
			//                    144-255   9
			//                    256-279   7
			//                    280-287   8
			//                   ------------------
			0:"00110000", 1:"00110001", 2:"00110010", 3:"00110011", 4:"00110100", 5:"00110101", 6:"00110110", 7:"00110111", 8:"00111000",
			9:"00111001", 10:"00111010", 11:"00111011", 12:"00111100", 13:"00111101", 14:"00111110", 15:"00111111", 16:"01000000",
			17:"01000001", 18:"01000010", 19:"01000011", 20:"01000100", 21:"01000101", 22:"01000110", 23:"01000111", 24:"01001000",
			25:"01001001", 26:"01001010", 27:"01001011", 28:"01001100", 29:"01001101", 30:"01001110", 31:"01001111", 32:"01010000",
			33:"01010001", 34:"01010010", 35:"01010011", 36:"01010100", 37:"01010101", 38:"01010110", 39:"01010111", 40:"01011000",
			41:"01011001", 42:"01011010", 43:"01011011", 44:"01011100", 45:"01011101", 46:"01011110", 47:"01011111", 48:"01100000",
			49:"01100001", 50:"01100010", 51:"01100011", 52:"01100100", 53:"01100101", 54:"01100110", 55:"01100111", 56:"01101000",
			57:"01101001", 58:"01101010", 59:"01101011", 60:"01101100", 61:"01101101", 62:"01101110", 63:"01101111", 64:"01110000",
			65:"01110001", 66:"01110010", 67:"01110011", 68:"01110100", 69:"01110101", 70:"01110110", 71:"01110111", 72:"01111000",
			73:"01111001", 74:"01111010", 75:"01111011", 76:"01111100", 77:"01111101", 78:"01111110", 79:"01111111", 80:"10000000",
			81:"10000001", 82:"10000010", 83:"10000011", 84:"10000100", 85:"10000101", 86:"10000110", 87:"10000111", 88:"10001000",
			89:"10001001", 90:"10001010", 91:"10001011", 92:"10001100", 93:"10001101", 94:"10001110", 95:"10001111", 96:"10010000",
			97:"10010001", 98:"10010010", 99:"10010011", 100:"10010100", 101:"10010101", 102:"10010110", 103:"10010111", 104:"10011000",
			105:"10011001", 106:"10011010", 107:"10011011", 108:"10011100", 109:"10011101", 110:"10011110", 111:"10011111", 112:"10100000",
			113:"10100001", 114:"10100010", 115:"10100011", 116:"10100100", 117:"10100101", 118:"10100110", 119:"10100111", 120:"10101000",
			121:"10101001", 122:"10101010", 123:"10101011", 124:"10101100", 125:"10101101", 126:"10101110", 127:"10101111", 128:"10110000",
			129:"10110001", 130:"10110010", 131:"10110011", 132:"10110100", 133:"10110101", 134:"10110110", 135:"10110111", 136:"10111000",
			137:"10111001", 138:"10111010", 139:"10111011", 140:"10111100", 141:"10111101", 142:"10111110", 143:"10111111", 144:"110010000",
			145:"110010001", 146:"110010010", 147:"110010011", 148:"110010100", 149:"110010101", 150:"110010110", 151:"110010111", 152:"110011000",
			153:"110011001", 154:"110011010", 155:"110011011", 156:"110011100", 157:"110011101", 158:"110011110", 159:"110011111", 160:"110100000",
			161:"110100001", 162:"110100010", 163:"110100011", 164:"110100100", 165:"110100101", 166:"110100110", 167:"110100111", 168:"110101000",
			169:"110101001", 170:"110101010", 171:"110101011", 172:"110101100", 173:"110101101", 174:"110101110", 175:"110101111", 176:"110110000",
			177:"110110001", 178:"110110010", 179:"110110011", 180:"110110100", 181:"110110101", 182:"110110110", 183:"110110111", 184:"110111000",
			185:"110111001", 186:"110111010", 187:"110111011", 188:"110111100", 189:"110111101", 190:"110111110", 191:"110111111", 192:"111000000",
			193:"111000001", 194:"111000010", 195:"111000011", 196:"111000100", 197:"111000101", 198:"111000110", 199:"111000111", 200:"111001000",
			201:"111001001", 202:"111001010", 203:"111001011", 204:"111001100", 205:"111001101", 206:"111001110", 207:"111001111", 208:"111010000",
			209:"111010001", 210:"111010010", 211:"111010011", 212:"111010100", 213:"111010101", 214:"111010110", 215:"111010111", 216:"111011000",
			217:"111011001", 218:"111011010", 219:"111011011", 220:"111011100", 221:"111011101", 222:"111011110", 223:"111011111", 224:"111100000",
			225:"111100001", 226:"111100010", 227:"111100011", 228:"111100100", 229:"111100101", 230:"111100110", 231:"111100111", 232:"111101000",
			233:"111101001", 234:"111101010", 235:"111101011", 236:"111101100", 237:"111101101", 238:"111101110", 239:"111101111", 240:"111110000",
			241:"111110001", 242:"111110010", 243:"111110011", 244:"111110100", 245:"111110101", 246:"111110110", 247:"111110111", 248:"111111000",
			249:"111111001", 250:"111111010", 251:"111111011", 252:"111111100", 253:"111111101", 254:"111111110", 255:"111111111", 256:"0000000",
			257:"0000001", 258:"0000010", 259:"0000011", 260:"0000100", 261:"0000101", 262:"0000110", 263:"0000111", 264:"0001000",
			265:"0001001", 266:"0001010", 267:"0001011", 268:"0001100", 269:"0001101", 270:"0001110", 271:"0001111", 272:"0010000",
			273:"0010001", 274:"0010010", 275:"0010011", 276:"0010100", 277:"0010101", 278:"0010110", 279:"0010111", 280:"11000000",
			281:"11000001", 282:"11000010", 283:"11000011", 284:"11000100", 285:"11000101", 286:"11000110", 287:"11000111"
		},

		// Static DISTANCE Map :: 0..29 => binstr (5 bit chars)
		//----------------------------------
		DSMP:
		{
			// DEFLATE spec:     DS SYMBOL  CL(bits)
			//                   ------------------
			//                    0-29      5
			//                   ------------------
			0:"00000", 1:"00001", 2:"00010", 3:"00011", 4:"00100", 5:"00101", 6:"00110", 7:"00111", 8:"01000",
			9:"01001", 10:"01010", 11:"01011", 12:"01100", 13:"01101", 14:"01110", 15:"01111", 16:"10000",
			17:"10001", 18:"10010", 19:"10011", 20:"10100", 21:"10101", 22:"10110", 23:"10111", 24:"11000",
			25:"11001", 26:"11010", 27:"11011", 28:"11100", 29:"11101"
		},

		L2SY: String.fromCharCode.apply(0,
		//----------------------------------
		// `L2SY.charCodeAt(len)` returns the Length Symbol (lsym) for length `len` (3 <= len <= 258) => 257..285
		// [REM] Lengths 0,1,2 are not used.
		[0,0,0,
		257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,
		273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,
		277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,
		279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,
		281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,
		282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,
		283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,
		284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285]
		),

		D2SY: function(/*1..16383*/d,  k,r)
		//----------------------------------
		// Returns the Dist Symbol (dsym) for distance 'd' (1 <= d <= 32768)
		// this :: any
		// => 0..29
		{
			// Code Bits Dist     Code Bits   Dist        Code Bits Distance
			// ---- ---- ----     ---- ----  ------       ---- ---- --------
			//   0   0    1        10   4     33-48       20    9   1025-1536
			//   1   0    2        11   4     49-64       21    9   1537-2048
			//   2   0    3        12   5     65-96       22   10   2049-3072
			//   3   0    4        13   5     97-128      23   10   3073-4096
			//   4   1   5,6       14   6    129-192      24   11   4097-6144
			//   5   1   7,8       15   6    193-256      25   11   6145-8192
			//   6   2   9-12      16   7    257-384      26   12  8193-12288
			//   7   2  13-16      17   7    385-512      27   12 12289-16384
			//   8   3  17-24      18   8    513-768      28   13 16385-24576
			//   9   3  25-32      19   8   769-1024      29   13 24577-32768

			if (d <= 4) return d - 1;
			r = callee[k='_'+d] || ( callee[k] = 4*(d<7) || 5*(d<9) || 6*(d<13) || 7*(d<17) || 8*(d<25) ||
				9*(d<33) || 10*(d<49) || 11*(d<65) || 12*(d<97) || 13*(d<129) || 14*(d<193) || 15*(d<257) ||
				16*(d<385) || 17*(d<513) || 18*(d<769) || 19*(d<1025) || 20*(d<1537) || 21*(d<2049) || 22*(d<3073) ||
				23*(d<4097) || 24*(d<6145) || 25*(d<8193) || 26*(d<12289) || 27*(d<16385) || 28*(d<24577) || 29 );
			return r;
		},

	})

	//==========================================================================
	// LZ-ALGO : FIND LONGEST PREFIX LENGTH/DISTANCE
	// (Just an approximation of LZ77: that's the best we can do in ExtendScript)
	//==========================================================================

	[PRIVATE]

	({

		PRFX: function(/*str*/input,/*uint*/index,/*uint*/maxLen,/*uint*/maxDis,/*3<=uint*/minLen,  x,y,q,n,p,z,B,ko,md,r)
		//----------------------------------
		// (Find-Longest-Prefix.)
		// Given input :: "...<queue>" -- where <queue> := input.slice(index,index+maxLen) --
		// find the longest <queue> prefix already available BEFORE index.
		// The highest index pos (< index) is then considered: return the {dist,len} of
		// the match, where `dist` is the positive distance from index (i.e. `index-pos`)
		// and `len` the match length (<= maxLen).
		// this :: ~
		// => { dist:1..maxDis, len:3..maxLen }& [OK]  |  0 [KO]
		{
			maxDis > index && (maxDis=index); // Sanitize maxDis

			// Left-shift and reduce input to the minimum area (~2X faster)
			// Rem: `index-maxDis` is the lowest allowed position (absolue)
			y = index + maxLen;
			0 < (x=index-maxDis) && ( index-=x );                          // index is now the 0-index relative to the reduced input
			( 0 < x || y < input.length ) && (input=input.slice(x,y));

			// Queue and 'actual max length' (n)
			q = input.slice(index);                                        // <queue> portion (limited to maxLen but could be shorter!)
			if( minLen > (n=q.length) ) return 0;                          // Not enough characters in input to satisfy minLen.

			y = index-1;                                                   // highest allowed index (used in lastIndexOf), avoids recalculation
			x = input.lastIndexOf(q.slice(0,minLen),y);                    // x :: previous index of the minimum match, or -1.
			if( 0 > x ) return 0;                                          // min_match not found before index --> KO (no need to investigate further)

			// Tests have shown that pre-checking the *full* match via
			// `input.lastIndexOf(q,y)` tends to slow down the algorithm.
			// Better is to preset B := [ <min>, n ] when entering the loop.
			// The full_match case (z=n) is still detected quickly.

			for
			(
				ko=0, p=x, z=minLen,                                       // Preset exit state: minMatch at p=x, length z=1
				B = [ z, n ] ;                                             // `B` represents [infSize,supSize] :: (tested,untested)

				1 < B[1]-B[0] ;                                            // loop as long as a size exists between infSize and supSize

				(
				 ( ko = +(0 > (x=input.lastIndexOf(q.slice(0,md=(B[0]+B[1])>>>1),y))) ) // test the mid_match of size `md`: ko if not-found,
				 || (p=x, z=md)                                                         // otherwise p=midIndex,z=midSize
				),

				B[ko]=md                                                   // ...and reduce the interval:
			);

			// So far, (p,z) is a known solution.
			// - if ko==1, md is a KO supSize and infSize is good, nothing to do
			// - if ko==0, md is a OK infSize and supSize hasn't been tested yet
			//             this test is only relevant if B[1] > minLen
			(!ko) && minLen < (md=B[1])
			&& 0 <= (x=input.lastIndexOf(q.slice(0,md),y))
			&& ( p=x, z=md ); // Better solution

			// Return a volatile {dist,len} structure.
			// ---
			r = callee.Q || (callee.Q={ dist:0, len:0 });
			return (r.dist=index-p), (r.len=z), r;
		},

		LZCF: function(/*uint=15*/maxLen,/*uint=auto*/maxDis,/*uint=3*/minLen,  mx,LBT)
		//----------------------------------
		// (Config-PRFX-Params) Validate input params for PRFX.
		//  - maxLen :: 3..258    (def 15)
		//  - maxDis :: 3..16384  (def 2047)
		//  - minLen :: 3..maxLen (def 3)
		// [REM] The storage of (maxLen,maxDis) should require at most 31 bits.
		// this :: ~
		// => { minLen, maxLen, maxDis, lenBits }  |  false [ERR] + .EMSG
		{
			// [CHG260204] maxlen and maxDis reflect actual maxima (e.g 258,16384)
			// while *token encoding* only requires resp.
			//   • mxLenCode = maxLen - 3
			//   • mxDisCode = maxDis - 1
			// (since maxLen>=3 AND maxDis >= 1).
			// ---

			const MIN_LEN = 3;      // Absolute minimum match length (minLen can be higher)
			const MAX_LEN = 258;    // Absolute maximum match length (maxLen can be lower)
			const MIN_DIS = 3;      // Absolute minimum value of maxDis (this is not the minimum distance per se)
			const MAX_DIS = 16384;  // Absolute maximum value of maxDis

			// Bit allocation logic
			// ---
			try
			{
				(maxLen >>>= 0) || (maxLen=15);
				if( maxLen < MIN_LEN || maxLen > MAX_LEN) throw __("Invalid parameter: `maxLen` (%1) must be between %2 and %3.",maxLen,MIN_LEN,MAX_LEN);
				for( mx=maxLen-3, LBT=0 ; mx > ( 1 << ++LBT ) ; ); // [REM260204] maxLen :: 3+mxLenCode
				// ---
				(maxDis >>>= 0) || ( maxDis=Math.min(MAX_DIS,1<<(15-LBT)) ); // [REM260204] maxDis :: 1+mxDisCode
				if( maxDis < MIN_DIS || maxDis > MAX_DIS) throw __("Invalid parameter: `maxDis` (%1) must be between %2 and %3.",maxDis,MIN_DIS,MAX_DIS);
				if( maxDis > (1<<(15-LBT)) ) throw __("Invalid parameter: `maxDis` (%1) cannot be greater than %2.",maxDis,1<<(15-LBT));
				// ---
				minLen = Math.max(MIN_LEN, minLen>>>0); // At least MIN_LEN
				if( minLen > maxLen ) throw __("Invalid parameter: `minLen` (%1) cannot be greater than `maxLen` (%2).",minLen,maxLen);
			}
			catch(e)
			{
				callee.EMSG = ''+e;
				return false;
			}

			return {
				minLen: minLen,
				maxLen: maxLen,
				maxDis: maxDis,
				lenBits: LBT,
			};
		}
		.setup
		({
			EMSG: '',
		}),

	})

	//==========================================================================
	// STATIC H-TREE COMPRESSION - BLOCK TYPE 1
	// <IS_LAST> <BTYPE> <BITSTREAM>
	//==========================================================================

	[PRIVATE]

	({

		DEFC: function(/*str*/data,/*uint=15*/maxLen,/*uint=auto*/maxDis,/*uint=auto*/minLen,  cfg,LBT,n,r,out,iSup,len,dis,i,c,cc,t)
		//----------------------------------
		// (Default-Static-Compression.) Fastest LZ Compression for static Huffman encoding,
		// bypassing frequency collection.
		// {str}  data    String formed of 8-bit characters: \x00 <= data[i] <= \xFF
		// {uint} maxLen  Max length of a match (3..258). Default: 15.
		// {uint} maxDis  Max distance of a match (3..16384). Default: auto.
		//                This implementation reduces the upper bound [DEFLATE spec says 32768].
		// {uint} minLen  Min length of a match (3..maxLen). Default: 3.
		// {obj} ret
		//       {
		//       tokens:     string of compressed tokens, <length:distance> being encoded
		//                   as a single UTF16 char in \(0x8000|((dis-1)<<LBT)|(len-3)) form.
		//       lenBits:    Number of len bits used in <length:distance> tokens.
		//       }
		// ---
		// this :: ~
		// => { tokens:str, lenBits:uint }  |  INTERNAL_ERR
		{
			const CHR = String.fromCharCode;

			// LZ-config and data structure
			// ---
			const LZ = this.PRFX; // Find-longest-prefix algo
			(cfg=this.LZCF(maxLen,maxDis,minLen)) || error( __("Internal %1 error: %2",callee.µ,this.LZCF.EMSG), callee );
			// ---
			minLen = cfg.minLen;
			maxLen = cfg.maxLen;
			maxDis = cfg.maxDis;
			LBT = cfg.lenBits;

			n = data.length;
			r = { lenBits: LBT };

			// Main compression loop
			// ---
			for( out=data.slice(0,i=minLen), iSup=n-minLen ; i < iSup ; out += c, i += len )
			if( t=LZ(data, i, maxLen, maxDis, minLen) )
			{
				// Match found -> <dis-1|len-3> token
				len = t.len;
				dis = t.dist;
				c = CHR( 0x8000 | ((dis<<LBT)-1) | (len-3) );
			}
			else
			{
				len = 1;
				c = data.slice(i,1+i);
			}
			i < n && (out += data.slice(i));

			r.tokens = out + CHR(256); // Append EOB
			return r;
		},

	})

	//==========================================================================
	// DYNAMIC H-TREE COMPRESSION (BLOCK TYPE 2)
	// <IS_LAST> <BTYPE> <HLIT> <HDIST> <HCLEN> <clCodeLengths> <lldsCodeLengths> <BITSTREAM...>
	//==========================================================================

	[PRIVATE]

	({

		PKMG: function(/*uint[]&*/symFreqs,/*uint<=32*/MAX_BITS,/*bool=0*/NEW_ARR,  INI,order,n,capa,flags,prv,cur,msk,i,iSup,z,p,q,hi,lo,nn,k,a)
		//----------------------------------
		// (Package-Merge.) Optimized Package-Merge for NonZero Frequencies (NZF).
		// {arr}  freqs     UTF16-encoded frequencies for any symbol < symFreqs.length
		//                  Each frequency must be in 0-0xFFFF.
		//                  Implementation limit: `symFreqs` can contain *at most* 65535 NZFs.
		// {uint} MAX_BITS  Maximum allowed code length <= 32
		//                  Rem: with MAX_BITS bits, we can encode at most 2^MAX_BITS symbols.
		//                  Implementation limit (<=32) for uint32 bit masking.
		// {bool} NEW_ARR   If set, return a new array (keep symFreqs unchanged.)
		//                  Default is FALSE since we usually don't keep original frequencies.
		// The returned array (symFreqs or a new one) is then updated with the optimal CodeLength
		// for each symbol (zero-frequency elements aren't modified). For convenience, an extra
		// MAX_VAL property is set to the maximum length used.
		// ---
		// Example 1 - from <github.com/sellibitze/packagemerge-rs/blob/master/src/lib.rs>
		//   PKMG( [1,1,2,4,8,16,32], 5 ) --> [5,5,5,5,3,2,1]
		// Example 2 - from <create.stephan-brumme.com/length-limited-prefix-codes>
		//   PKMG( [0,1,270,1,6,0,10,20,0], 4 ) --> [0,4,1,4,4,0,4,2,0]
		// ---
		// this :: any
		// => uint[]&  + .MAX_VAL ; The incoming array is returned w/ updated values (bit lengths).
		//    | INTERNAL_ERR
		{
			const CHR = String.fromCharCode;

			// Implementation limit.
			32 >= MAX_BITS
			|| error( __("Internal %1 error: MAX_BITS (%2) too large. Should be <= 32.",callee.µ,MAX_BITS), callee ); // Should never happen in this module.

			// 1. Extract NZFs and sort them, keeping track of OrderedNZFIndex => OriginalIndex.
			// ---
			NEW_ARR && (symFreqs=symFreqs.slice());
			symFreqs.MAX_VAL = 0; // Init extra prop
			// ---
			for( INI=[], i=-1 ; ++i < symFreqs.length ; (k=symFreqs[i]) && (INI[INI.length]=CHR(k,i)) ); // INI :: `<fq><idx>`[]


			n = INI.length;                                                                              // n :: number of NZFs
			if( 0===n ) return symFreqs;                                                                 // n==0 -> return [0...0] (unchanged)
			if( 1===n ) return (symFreqs[INI[0].charCodeAt(1)]=1), (symFreqs.MAX_VAL=1), symFreqs;       // n==1 -> return [0...0, 1, 0...0] (single freq) [FIX260126]
			// Ensure MAX_BITS is large enough to encode all symbols!
			(n >>> MAX_BITS)
			&& error( __("Internal %1 error: MAX_BITS (%2) too small. Should be >= %3.",callee.µ,MAX_BITS,(n<<1)), callee ); // Should never happen in this module.

			for( INI.sort(), order='', i=-1 ; ++i < n ; order += INI[i].slice(1), INI[i]='\0'+INI[i].slice(0,1) ); // Don't use charAt

			// ---
			// {str} order ::  `<idxFq0><idxFq1>...`, where idxFq_i is the original symFreqs' index for index i in INI
			// {arr} INI   ::  [ `\0<Fq0>`, `\0<Fq1>`, ... ]  Fqi <= '\uFFFF', each chunk has length 2.
			// ---

			capa = 2*n - 1;         // Maximum items in a binary tree with n leaves
			flags = Array(capa);    // Bit flags tracking merge history

			// 2. Main loop: build the package-merge tree level by level
			for( prv=INI, z=0 ; ++z < MAX_BITS ; prv=cur ) // Rem: INI already covers level 0.
			{
				// Next struct: merge of INI `\0<fqi>` and `<hi><lo>_`

				// Create pairs from previous level and append to INI  ;  pair :: `<hi><lo>_` (length==3)
				for( cur=INI.slice(), iSup=prv.length-1, i=-2 ; iSup > (i+=2) ; cur.push(CHR(hi,lo)+'_') )
				{
					p = prv[i];
					q = prv[1+i];

					hi = p.charCodeAt(0) + q.charCodeAt(0);
					lo = p.charCodeAt(1) + q.charCodeAt(1);
					lo > 0xFFFF && ( hi+=(lo>>>16), lo&=0xFFFF );
				}
				cur.sort();

				// Process flags ; bit mask for this depth level is 1 << z
				for( msk=1<<z, i=-1 ; ++i < cur.length ; 3==cur[i].length && (flags[i] |= msk) );
			}

			// 3. Backtracking phase: determine code lengths by tracing back through the tree
			// ---
			for( a=Array(n), nn=capa-1, z=MAX_BITS ; z-- > 0 && nn > 0 ; nn = 2*k )
			for( msk=1<<z, k=0, i=-1 ; ++i < nn ; 0 === (msk&flags[i]) ? a[i-k]=1+(0|a[i-k]) : ++k );
			// a :: [len0, len1...] corresponding to the n NZFs.
			symFreqs.MAX_VAL = a[0];

			// 4. Update original array and return.
			for( i=-1 ; ++i < n ; symFreqs[order.charCodeAt(i)]=a[i] );

			return symFreqs;
		},

		CLST: function(/*(0..15)[286+30]*/LL_DS,/*uint[19]&*/freqs,  r,n,i,z,di,sb,c,t)
		//----------------------------------
		// (Code-Lengths-Stream.) Generate the stream to encode while dealing with repeat
		// codes 16,17,18 and *updating freqs[symbol] accordingly*.
		// Rem: LL_DS is the concat of LL and DS code lengths, the symbols considered
		//      here are 0..15 (CL symbols), i.e. the *values* found in LL_DS.
		//  => <sym>(<xtra><xbits>)?[]     ; stream to encode
		{
			const CHR = String.fromCharCode;

			for( r=Array(), n=LL_DS.length, i=0 ; i < n ; i += di )
			{
				sb = LL_DS[i]; // 0 <= sb <= 15

				// z :: how many times `sb` occurs from here (z>=1)
				for( z=1 ; (i+z) < n && sb===LL_DS[i+z] ; z++ );
				di = z;

				// Nonzero Case
				// ---
				if( sb )
				{
					freqs[sb]++;
					r.push(c=CHR(sb));                                 // Emit the symbol alone
					z--;                                               // Remaining count (may be 0 if single)

					if( 3 <= z )                                       // At least 3 more times?
					{
						6 < (t=z) && (t=6);                            // t = min(z,6) => t == 3|4|5|6 => 0 <= t-3 <= 3 (2bits)
						freqs[16]++;
						r.push(CHR(16,t-3,2));                         // Emit t×sb using symbol 16  (16,t-3,2)
						z -= t;                                        // Remaining count
					}

					for( ; 0 < z ; freqs[sb]++, r.push(c), z-- );      // Emit the remaing z×sb as singles.
					continue;
				}

				// Zero Case
				// ---
				for( ; 0 < z ; r.push(c), z-=t )
				{
					if( 11 <= z )                                      // At least 11X?
					{
						138 < (t=z) && (t=138);                        // t = min(z,138) => t = 11|12|...|137|138  =>  0 <= t-11 <= 127 (7bits)
						freqs[18]++;
						c = CHR(18,t-11,7);                            // Emit t×sb using symbol 18  (18,t-11,7)
					}
					else if( 3 <= z )                                  // At least 3X?
					{
						10 < (t=z) && (t=10);                          // t = min(z,10) => t == 3|...|10 => 0 <= t-3 <= 7 (3bits)
						freqs[17]++;
						c = CHR(17,t-3,3);                             // (17,t-3,3)
					}
					else
					{
						freqs[sb]++;
						c = '\0';
						t = 1;
					}
				}
			}

			return r;
		},

		IDYN: function(/*BitWriter&*/BW,/*(0..15)[286]&*/LL,/*(0..15)[30]&*/DS,  HLIT,HDIS,HCLEN,CL,strm,map,ord,lastNZ,i,t,k)
		//----------------------------------
		// (Init-Dynamic-Tree.) Encode and write the dynamic H-tree through BitWriter, based on LL/DS frequencies.
		// Stream :: <IS_LAST> <BTYPE> <HLIT> <HDIST> <HCLEN> <clCodeLengths> <lldsCodeLengths> <BITSTREAM...>
		//                             ========================================================
		// {obj&} BW :: BitWriter
		// {arr}  LL :: CodeLength (0-15) for each LL symbol in 0..285, LL.MAX_BITS is preset.
		// {arr}  DS :: CodeLength (0-15) for each DS symbol in 0..29,  DS.MAX_BITS is preset.
		// ---
		// this :: ~
		// => undef
		{
			// Header.
			// ---
			HLIT = LL.length-257;       // Strictly 29 (might be truncated for optim?)
			HDIS = DS.length - 1;       // Strictly 29 (might be truncated for optim?)
			BW.writeBits(HLIT, 5);
			BW.writeBits(HDIS, 5);

			// Combine Code Lengths, tally freqs and generate CL stream and CL code lengths.
			// LL.concat(DS)
			// ---
			CL = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; // Init freqs for the 19 CL symbols (0..18)
			strm = this.CLST(LL.concat(DS), CL);          // Compute LL freqs and generate strm :: <sym>(<xtra><xbits>)?[]

			// ---
			// Rem: strm.length may be < (LL+DS).length
			// 1st char is the symb in 0-18 (\x00-\x12), next chars if present are `<xtra><xbits>` data.
			// ---

			// CL SYMBOL   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18
			//            -----------------------------------------------------------------
			// Before:    14, 0, 0, 4, 5, 7,13, 6, 8, 2, 9, 4, 2, 4, 0, 0, 2, 5, 4   (freq)
			// After       3, 0, 0, 5, 4, 4, 3, 4, 4, 5, 3, 4, 5, 4, 0, 0, 5, 4, 4   (bits)
			CL = this.PKMG(CL, 7); // Package merge: now CL contains optimal code lengths in 0..7.

			// Write HCLEN and CL code lengths.
			ord = this.CL_ORDER; // str :: <0..18>[19]  ; permutation (0..18) -> (0..18)
			for( lastNZ=18 ; lastNZ >= 4 && CL[ord.charCodeAt(lastNZ)] === 0 ; lastNZ-- );
			// ---
			BW.writeBits( (HCLEN=-3+lastNZ), 4 );                                      // <HCLEN> (4 bits)
			for( t=4+HCLEN, i=-1 ; ++i < t ; BW.writeBits(CL[ord.charCodeAt(i)],3) );  // <clCodeLengths> 3*HCLEN + 4 bits

		    map = this.HMAP(CL);                                                       // map :: { CL_SYMB => bin_str }
		    // E.g.
		    // { 0:"000", 3:"11100", 4:"0110", 5:"0111", 6:"001", 7:"1000", 8:"1001", 9:"11101",
		    //  10:"010", 11:"1010", 12:"11110", 13:"1011", 16:"11111", 17:"1100", 18:"1101" }

		    // Encode LL/DS code lengths.
			for( i=-1 ; ++i < strm.length ; )
			{
				t = strm[i]; // <sym>(<xtra><xbits>)?
				BW.writeBits( map[t.charCodeAt(0)] );
				3 == t.length && BW.writeBits( t.charCodeAt(1), t.charCodeAt(2) );
			}
		},

		DYNC: function(/*str*/data,/*uint=15*/maxLen,/*uint=auto*/maxDis,/*uint=auto*/minLen,  cfg,LBT,n,r,LL,DS,llMx,dsMx,out,iSup,len,dis,i,c,cc,t)
		//----------------------------------
		// (Dynamic-Compression.) Huffman-aware LZ Compression *with Frequency Collection* aimed at dynamic
		// H-Tree construction
		// {str}  data    String formed of 8-bit characters: \x00 <= data[i] <= \xFF
		// {uint} maxLen  Max length of a match (3..258). Default: 15.
		// {uint} maxDis  Max distance of a match (3..16384). Default: auto.
		//                This implementation reduces the upper bound [DEFLATE spec says 32768].
		// {uint} minLen  Min length of a match (3..maxLen). Default: 3.
		// ---
		// {obj} ret
		//       {
		//       tokens:     string of compressed tokens, <length:distance> being encoded
		//                   as a single UTF16 char in \(0x8000|((dis-1)<<LBT)|(len-3)) form.
		//       lenBits:    Number of len bits used in <length:distance> tokens.
		//       llData:     idx=>freq map for LL symbols (incl. zero-frequency symbols),
		//                   i.e. array of 286 uint16.
		//       dsData:     idx=>freq map for DS symbols (incl. zero-frequency symbols),
		//                   i.e. array of 30 uint16.
		//       }
		// ---
		// this :: ~
		// => { tokens:str, lenBits:uint, llData:uint16[286], dsData:uint16[30] }
		//    | INTERNAL_ERR
		{
			const CHR = String.fromCharCode;
			const ROU = Math.round;
			const L2S = this.L2SY; // str
			const D2S = this.D2SY; // fct

			// LZ-Config and data structure
			// ---
			const LZ = this.PRFX; // Find-longest-prefix algo
			(cfg=this.LZCF(maxLen,maxDis,minLen)) || error( __("Internal %1 error: %2",callee.µ,this.LZCF.EMSG), callee );
			minLen = cfg.minLen;
			maxLen = cfg.maxLen;
			maxDis = cfg.maxDis;
			LBT = cfg.lenBits;

			n = data.length;
			r = { lenBits: LBT };

			(LL = r.llData = Array(286))[256] = 1;                                        // Any `undefined` LL[cc] will be coerced to 0
			llMx = 1;                                                                     // Max LL count
			DS = r.dsData = Array(30);                                                    // Any `undefined` DS[cc] will be coerced to 0
			dsMx = 0;                                                                     // Max DS count

			// Main compression loop with frequency collection
			// ---
			for( out=data.slice(0,minLen), i=-1 ; ++i < minLen && i < n ;                 // Trailing literals
				(cc=data.charCodeAt(i)), llMx < (t=LL[cc]=1+(LL[cc]>>>0)) && (llMx=t) );  // Update LL symbol freq

			for( iSup=n-minLen ; i < iSup ; out += c, i += len )
			if( t=LZ(data, i, maxLen, maxDis, minLen) )                                   // LZ compression?
			{
				len = t.len;
				dis = t.dist;
				c = CHR( 0x8000 | ((dis-1)<<LBT) | (len-3) );                             // Compute <dis|len> token
				// ---
				cc = L2S.charCodeAt(len), llMx < (t=LL[cc]=1+(LL[cc]>>>0)) && (llMx=t);   // Update LL symbol freq
				cc = D2S(dis), llMx < (t=DS[cc]=1+(DS[cc]>>>0)) && (dsMx=t);              // Update DS symbol freq
			}
			else
			{
				len = 1;
				c = data.slice(i,1+i); // Bypass charAt bug with \0
				cc = c.charCodeAt(0), llMx < (t=LL[cc]=1+(LL[cc]>>>0)) && (llMx=t);
			}

			if( i < n )for( out += data.slice(i) ; n > i ;                                   // Remaining literals
				(cc=data.charCodeAt(i++)), llMx < (t=LL[cc]=1+(LL[cc]>>>0)) && (llMx=t) );   // Update LL symbol freq

			r.tokens = out + CHR(256);                                                       // Append EOB

			// Normalize LL/DS frequencies in 0..0xFFFF
			// ---
			c = +(0xFFFF < llMx && (0xFFFF/llMx));
			for( i=LL.length ; i-- ; (t=LL[i]||(LL[i]=0)) && c && (LL[i]=ROU(c*t)||1) );
			// ---
			c = +(0xFFFF < dsMx && (0xFFFF/dsMx));
			for( i=DS.length ; i-- ; (t=DS[i]||(DS[i]=0)) && c && (DS[i]=ROU(c*t)||1) );

			return r;
		},

	})

	//==========================================================================
	// DEFLATE COMPRESSOR
	//==========================================================================

	[PRIVATE]

	({
		ENCO: function(/*BitWriter&*/BW,/*str*/tokens,/*uint*/LBT,/*obj*/llMap,/*obj*/dsMap,  n,i,sb,len,dis,p,xb)
		//----------------------------------
		// (Encode-Bitstream.) Generic encoder for either static or dynamic H-tree.
		// Will encode the sequence of `tokens` using the supplied code maps `llMap`,`dsMap`.
		// this :: ~
		// => undef
		{
			const MSK = (1 << LBT) - 1;

			const L2S = this.L2SY;   // Len   -> LSym   (str)
			const LSB = this.LS2B;   // LSym  -> Base   (str) ; use LSym - 257
			const LSX = this.LS2X;   // LSym  -> Xbits  (str) ; use LSym - 257

			const D2S = this.D2SY;   // Dis   -> DSym   (fct)
			const DSB = this.DS2B;   // DSym  -> Base   (str)
			const DSX = this.DS2X;   // DSym  -> Xbits  (str)

			for( n=tokens.length, i=-1 ; ++i < n ; )
			{
				if( 256 >= (sb=tokens.charCodeAt(i)) )
				{
					// Literal or EOB
					BW.writeBits( llMap[sb] );
				}
				else
				{
					// Rebuild the Length/Distance pair
					len = 3 + (MSK&(sb&=0x7FFF));
					dis = 1 + (sb >> LBT);

					// Length
					BW.writeBits(llMap[sb=L2S.charCodeAt(len)]);
					(xb=LSX.charCodeAt(p=sb-257)) && BW.writeBits(len-LSB.charCodeAt(p),xb);

					// Distance
					BW.writeBits(dsMap[sb=D2S(dis)]);
					(xb=DSX.charCodeAt(p=sb)) && BW.writeBits(dis-DSB.charCodeAt(p),xb);
				}
			}
		},

		CBLK: function(/*str*/data,/*BitWriter&*/BW,/*{...}*/ops,  $$,sz,lbk,prf,mxLen,mnLen,mxDis,cmp,llMap,dsMap,t,x)
		//----------------------------------
		// (Compress-Block.) Compress and encode a block through $$.BitWriter and
		// return the final byte string. The incoming bytestream `data` is guaran-
		// teed to have at most `RCMP.MAX_BLK_LEN` bytes, that is 64K in the
		// current implementation. This max size is empirically deter mined so it
		// preserves good perf.
		//   ops :: { prefBlockType:0|1|2, isLastBlock:0|1,
		//            mxLen:3..258, mxDis:3..16384, mnLen:3..mxLen }
		// this :: ~
		// => undef
		{
			$$ = $.global[callee.µ.__root__]; // agnostic reference

			sz = data.length;
			if( !sz ) return; // Should not happen!

			lbk = ops.isLastBlock ? '1' : '0';
			prf = ops.prefBlockType; // 0|1|2
			// ---
			mxLen = ops.mxLen;
			mxDis = ops.mxDis;
			mnLen = ops.mnLen;

			// Supersedes block type pref, depending on size.
			sz < callee.COMP_MIN && (prf=0);
			sz > callee.UNCOMP_MAX && (prf=prf||2);

			switch( prf )
			{
				case 2: // Block Type 2 (Dynamic)
					(+$$.trace) && $$.trace( __("%1 > [CBLK] Compressing %2 bytes in dynamic mode (block type=2)",callee.µ, sz) );

					cmp = this.DYNC( data, mxLen, mxDis, mnLen );
					BW.writeBits(lbk).writeBits( 2, 2 );

					// ---
					// [REM] PKMG (package-merge) internally converts frequencies into
					// bit lengths, hence `llData&` and `dsData&` are updated so they
					// will support ~.HMAP. The bitlength 15 is required.
					// ---

					this.IDYN( BW, this.PKMG(cmp.llData, 15), this.PKMG(cmp.dsData, 15) );
					llMap = this.HMAP( cmp.llData );
					dsMap = this.HMAP( cmp.dsData );
					this.ENCO( BW, cmp.tokens, cmp.lenBits, llMap, dsMap );
					break;

				case 1: // Block Type 1 (Static)
					(+$$.trace) && $$.trace( __("%1 > [CBLK] Compressing %2 bytes in static mode (block type=1)",callee.µ, sz) );

					cmp = this.DEFC( data, mxLen, mxDis, mnLen );
					BW.writeBits(lbk).writeBits( 1, 2 );
					// ---
					llMap = this.LLMP; // static LL map
					dsMap = this.DSMP; // static DS map
					this.ENCO( BW, cmp.tokens, cmp.lenBits, llMap, dsMap );
					break;

				default: // Block Type 0 (Stored) :: <IS_LAST> <BTYPE> <PADDING> <LEN> <~LEN> <BITSTREAM>
					(+$$.trace) && $$.trace( __("%1 > [CBLK] Storing %2 bytes without compression (block type=0)",callee.µ, sz) );

					BW.writeBits(lbk).writeBits(0, 2);    // BFINAL, BTYPE=00
					BW.flush();  // Pad any partial byte to completion before each BTYPE=00 block

					x = 0xFFFF&~sz;                       // Bitwise complement (16 bits)
					t = String.fromCharCode
					(
						0xFF&sz, sz>>>8,                  // <LEN>   :: lo, hi
						0xFF&x,  x>>>8,                   // <~LEN>  :  lo, hi
					);

					BW.bytes += t + data;
			}
		}
		.setup
		({
			COMP_MIN:   10,   // Never compress size < 10
			UNCOMP_MAX: 256,  // Always compress size > 256 (btw a 'stored' block requires size <= 0xFFFF)
		}),

		RCMP: function(/*str*/src,  n,BW,ops,iSup,i)
		//----------------------------------
		// (Raw-Deflate-Compressor.) Generic entry point for 'RAW DEFLATE' compression.
		// This method supports `src` up to 1MB and will slice bytes into 64K blocks.
		// However, time perf is essentially linear and 100K already requires ~1s,
		// which is dramatically slower than `~.APZP`. This routine remains fast on
		// small sources (< 4K) and should be used at higher sizes only if APZP
		// is unavailable or failed.
		// Best compression ratio is obtained in dynamic mode (prefBlockType:2)
		// and (mxLen=10,mxDis=4096) seems to be the best config for TEXT data,
		// with no impact on time performance.
		// ---
		// Rem: BitWriter accumulates the compressed bytes up to the end, flush()
		//      being processed only at the *last block* stage. (Byte-padding
		//      MUST NOT be performed before!)
		// this :: ~
		// => str [OK]  |  false [ERR] + .EMSG
		{
			const MXB = callee.MAX_BLK_LEN;  // Max DEFLATE block size: 64K

			callee.EMSG = '';
			if( this.MAX_TO_DEFL < (n=src.length) )
			{
				callee.EMSG = __("The source stream (%1 KB) exceeds the maximum capacity %2 KB.", (n/1024).toFixed(1), this.MAX_TO_DEFL/1024);
				return false;
			}

			BW = $.global[callee.µ.__root__].BitWriter();
			ops = callee.OPS;
			iSup = n-MXB;

			for( ops.isLastBlock=0, i=0 ; i < iSup ; this.CBLK(src.slice(i,i+=MXB), BW, ops) );

			ops.isLastBlock=1; // Final block
			this.CBLK(src.slice(i), BW, ops);

			return BW.getResult();
		}
		.setup
		({
			EMSG: '',
			OPS:
			{
				isLastBlock:   1,     // Adjusted dynamically.
				prefBlockType: 2,     // Dynamic H-Tree (better ratio on average, no perf impact)
				// ---
				mxLen:         10,    // -> mxLen-3 = 7    (3bits)  ; yields very decent results.
				mxDis:         4096,  // -> mxDis-1 = 4095 (12bits) ; longest distance is better!
				mnLen:         3,     // There is no serious reason to increase this.
			},
			MAX_BLK_LEN: 0x10000,  // 64K
		}),

	})

	//==========================================================================
	// GZIP AND ZLIB WRAPPERS
	//==========================================================================

	[PRIVATE]

	({
		GZWP: function(/*str*/src,/*str*/rawDefl)
		//----------------------------------
		// (GZIP-Wrapper.) Given the original `src` (uncompressed) and its raw
		// DEFLATE bytestream `rawDefl`, return the minimal, valid GZIP bytestream:
		//   ID1 + ID2 + CMF + MTIME + [XFL][OS] + DEFLATE + CRC32 + ISIZE
		// this :: ~
		// => str
		{
			const CHR = String.fromCharCode;
			const LE = this.LE32;

			return this.GZIN + '\x08\x00' + LE(Math.floor((+new Date)/1e3)) + '\x00\x03' +
			       rawDefl + LE(this.CRC32(src)) + LE(0xFFFFFFFF&src.length);
		},

		ZLWP: function(/*str*/src,/*str*/rawDefl)
		//----------------------------------
		// (ZLIB-Wrapper.) Given the original `src` (uncompressed) and its raw
		// DEFLATE bytestream `rawDefl`, return the minimal, valid ZLIB bytestream:
		//   CMF + FLG + DEFLATE + ADLER32
		// CMF :: 0x78 (deflate method, 32K window) - this is standard
		// FLG :: 0x9C (fixed when no preset dictionary)
		// this :: ~
		// => str
		{
			return '\x78\x9C' + rawDefl + this.BE32(src.adler32());
		},

	})

	//==========================================================================
	// FAST ZIP COMPRESSOR (.zip)
	//==========================================================================

	[PRIVATE]

	({

		APZP: function(/*str|byte[]|File*/src,/*bool=0*/DEFLATE_ONLY,  $$,T,isTmpSrc,iniUtf8,srcName,ffSrc,fdSrc,ucf,ffZip,t,zip,nn,mm,tt,p,q,d,sz,z,fhd,cde,eoc,cm,flg)
		//----------------------------------
		// (App-Package-ZIP.) Make a ZIP stream from a source through `app.packageUCF`
		// and return either the whole PKZIP stream, or only the DEFLATE stream,
		// depending on `DEFLATE_ONLY`. Also used as a superfast DEFLATE compressor,
		// since the processed ZIP always uses CM=8.
		// - This method is always faster than RCMP if src > 2K (and significantly
		//   faster for larger files.) It also provides a better compression ratio
		//   and will support src > 1MB.
		// - In CS4, `app.packageUCF()` seems unable to properly package `\x00\x01\x02...`
		//   although $$.File.writeBinary() properly creates the temporary file. We suspect
		//   that the U+0000 character is the problem...
		// - `app.packageUCF()` fails if the source filename has non-ASCII chars (!)
		//   but the present routine solves the issue by maintaining the actual internal
		//   filename through UTF8 (when necessary.)
		// ---
		// this :: ~
		// => str [OK]  |  false [ERR] + EMSG   ; The returned string is either pure DEFLATE or PKZIP bytes.
		{
			const MIME = "application/IdExtenso"; // arbitrary mimetype
			const PKIN = this.PKIN;
			const U32 = this.LE32;
			const U16 = this.LE16;

			$$ = $.global[callee.µ.__root__]; // agnostic reference
			T = (+$$.trace) && $$.trace;
			T&&T( __("%1 > [APZP] Want to zip a %2 (length: %3).", callee.µ, (src?src.constructor.name:typeof src), (src||0).length) );

			callee.EMSG = '';

			// 1. Make sure we have a valid source
			// ---
			isTmpSrc = ffSrc = 0;
			while( src===Object(src) )
			{
				if( src instanceof File )
				{
					if( !src.exists )
					{
						callee.EMSG = __("The file %1 doesn't exist.",''+src);
						$$.warn( __("%1 > [APZP] %2", callee.µ, callee.EMSG) );
						return false;
					}
					ffSrc = src;
					T&&T( __("%1 > [APZP] Source file: %2", callee.µ, ffSrc.getDisplayName()) );
					break;
				}

				if( src instanceof Array )
				{
					try
					{
						src = String.fromCharCode.apply(0,src);
					}
					catch(e)
					{
						(+$$.warn) && $$.warn( __("%1 > [APZP] Cannot create the byte string from array %2", callee.µ,$$.JSON(src)) );
						src = false;
					}
					if( false !== src )
					{
						T&&T( __("%1 > [APZP] Array successfully converted to string.", callee.µ) );
						break;
					}
				}

				callee.EMSG = __("Invalid source argument (%1).",src.constructor.name);
				$$.warn( __("%1 > [APZP] %2", callee.µ, callee.EMSG) );
				return false;
			}
			if( 0===ffSrc )
			{
				if( 'string' != typeof src )
				{
					callee.EMSG = __("Invalid source argument (%1).",typeof src);
					return false;
				}
				if( !src.length )
				{
					callee.EMSG = __("Empty string.");
					return false;
				}
				T&&T( __("%1 > [APZP] Non-empty string available. (A temp source file is required.)", callee.µ) );
				isTmpSrc = 1; // want a temp source File (pending)
			}

			// 2. In any case, create a temp folder (in Folder.temp)
			// ---
			for
			(
				t=$$.File.stamp(5) ;                           // e.g "bazbo"
				(fdSrc=new Folder(Folder.temp+'/'+t)).exists ; // While existing folder...
				t = '_'+t                                      // ...preprend '_'
			);
			if( !fdSrc.create() )
			{
				callee.EMSG = __("Cannot create temp source folder %1.",''+fdSrc);
				$$.warn( __("%1 > [APZP] %2", callee.µ,callee.EMSG) );
				return false;
			}
			T&&T( __("%1 > [APZP] Set temp source folder: %2", callee.µ, ''+fdSrc) );

			// 3. Create or copy source file in fdSrc
			// ---
			iniUtf8 = false;                // No initial filename (so far)
			srcName = this.DUMMY_NAME;      // Dummy filename ('data.tmp')

			if( isTmpSrc )
			{
				// `DUMMY_NAME` is pure ascii so there is no issue with srcName
				// ---
				ffSrc = $$.File.writeBinary(fdSrc + '/' + srcName, src);
				if( !ffSrc )
				{
					callee.EMSG = __("Cannot write binary file.");
					$$.warn( __("%1 > [APZP] %2", callee.µ, callee.EMSG) );
					return false;
				}
				T&&T( __("%1 > [APZP] Temp source file (%2) successfully created from the binary stream %3.", callee.µ, ffSrc.getDisplayName(), src.trunc(100).toSource()) );
			}
			else
			{
				// ---
				// The filename `t.getDisplayName()` may have UTF8 chars that would
				// cause app.packageUCF to fail:
				// (1) If DEFLATE_ONLY is processed we don't need filename
				//     consistency so let's use the dummy name.
				// (2) If a full zip stream is expected, we want to restore the
				//     correct src filename but it may contain no-ascii chars.
				//     In this case :
				//     - store the original name, UTF8-encoded, in `iniUtf8` ;
				//     - create a dummy ASCII `srcName` with the exact same length.
				//     - restore the original name through byte manipulation (below)
				// ---

				if( !DEFLATE_ONLY )
				{
					srcName = ffSrc.name;         // Default case (URI notation)

					t = ffSrc.getDisplayName();   // May contain non-ascii chars
					tt = t.toUTF8();              // UTF8 expression

					if( t != tt )
					{
						iniUtf8 = tt;             // iniUtf8 :: Original UTF8 expression.

						srcName = Array(1+iniUtf8.length).join('a');
						4 < srcName.length && (srcName=srcName.slice(0,-4)+'.tmp'); // srcName :: `aa..aa.tmp` ( length == iniUtf8.length )

						T&&T( __("%1 > [APZP] Created the dummy filename %2 to store %3 (UTF8).", callee.µ, srcName.toSource(), iniUtf8.toSource()) );
					}
				}

				t = ffSrc; // Existing input file
				ffSrc = new File( fdSrc + '/' + srcName );
				if( !t.copy(ffSrc) )
				{
					callee.EMSG = "Cannot copy file.";
					$$.warn( __("%1 > [APZP] Cannot copy file %2 to %3.", callee.µ, ''+t, ''+ffSrc));
					return false;
				}
				T&&T( __("%1 > [APZP] Copied the input file into the temp folder: %2", callee.µ, ''+ffSrc) );
			}

			// 4. Create the zip file thru app.packageUCF.
			// [WARNING] Don't try to save the zip *within* fdSrc -> infinite loop!!!
			ffZip = (new File(fdSrc.parent + '/' + ffSrc.name + '.zip')).fresh();
			T&&T( __("%1 > [APZP] Declared the destination ZIP file: %2", callee.µ, ''+ffZip) );

			// [REM] app.packageUCF(srcFolder, destFile, mimeType) has three args since ID 7.0,
			// but there is no issue in passing the 3rd arg in CS4.
			try
			{
				app.packageUCF( fdSrc, ffZip, MIME );
				ucf = 1;
				T&&T( __("%1 > [APZP] app.packageUCF returned successfully.", callee.µ) );
			}
			catch(e)
			{
				ucf = 0;
				$$.warn( __("%1 > [APZP] app.packageUCF failed with args (%2,%3) -- %4", callee.µ,''+fdSrc,''+ffZip, ''+e) );
			}

			// 5. Remove ffSrc and fdSrc
			// [REM] Folders must be empty before they can be deleted.
			try
			{
				ffSrc.remove(); fdSrc.remove();
				T&&T( __("%1 > [APZP] Removed temp source folder.", callee.µ) );
			}
			catch(e){ $$.warn( __("%1 > [APZP] Cannot remove temp source folder -- %2", callee.µ,''+e) ); }

			if( !ucf )
			{
				// [REM260130] packageUCF may fail while still producing an (invalid) ZIP file!
				try{ ffZip.remove(); } catch(_){}
				callee.EMSG = "InDesign's packageUCF failed.";
				return false;
			}

			T&&T( __("%1 > [APZP] Reading the ZIP file, then removing it...", callee.µ) );

			// 6. Read ffZip data and retrieve the byte stream.
			zip = $$.File.readBinary(ffZip);
			try{ ffZip.remove(); } catch(_){}

			T&&T( __("%1 > [APZP] ZIP contents (first bytes): %2", callee.µ, zip.length ? zip.slice(0,30).toBytes('hexa').join(' ') : $$.JSON(zip)) );

			// Checkpoints
			// ---
			try
			{
				if( !zip.length ) throw "Empty zip!";
				if( 0 !== zip.indexOf(PKIN) ) throw "PKZIP header signature not found at the starting byte.";
				if( '\0\0' !== zip.slice(8,10) ) throw "CM method of mimetype should be 0.";
				sz = zip.charCodeAt(18) + 0x100*(zip.charCodeAt(19))      // Size of mime data
				   + 0x10000*zip.charCodeAt(20)
				   + 0x1000000*zip.charCodeAt(21);
				nn = zip.charCodeAt(26) + 0x100*zip.charCodeAt(27);       // mime file name length (should be 8)
				mm = zip.charCodeAt(28) + 0x100*zip.charCodeAt(29);       // mime file extra length (should be 0)
				p = 30+nn+mm+sz;                                          // Offset of good file header signature
				if( zip.slice(p,p+4) !== PKIN ) throw "PKZIP header signature not found (2nd header).";

				// Good file CM method (16bits) : we expect cm==8 (should be the case in ID.)
				cm = zip.charCodeAt(p+8) + 0x100*zip.charCodeAt(p+9);
				if( 8 != cm ) throw __("CM method should be 8. Found %1 (%2)!", cm, cm.toHexa("", 4));
				sz = zip.charCodeAt(p+18) + 0x100*(zip.charCodeAt(p+19))  // Size of good data
				   + 0x10000*zip.charCodeAt(p+20)
				   + 0x1000000*zip.charCodeAt(p+21);
				// Start position (p+30+nn+mm)
				nn = zip.charCodeAt(p+26) + 0x100*zip.charCodeAt(p+27);   // good file name length
				mm = zip.charCodeAt(p+28) + 0x100*zip.charCodeAt(p+29);   // good file extra length (should be 0)
				q = p+30+nn+mm;                                           // Start of good (DEFLATE) data
			}
			catch(e)
			{
				callee.EMSG = ''+e;
				$$.warn( __("%1 > [APZP] %2", callee.µ, callee.EMSG) );
				return false;
			}

			if( DEFLATE_ONLY )
			{
				T&&T( __("%1 > [APZP] Returning the DEFLATE stream only.", callee.µ) );
				return zip.slice(q,q+sz);
			}

			try
			{
				q += sz;                                                  // q :: MimeCDEntry offset
				nn = zip.charCodeAt(q+28) + 0x100*zip.charCodeAt(q+29);   // mimeCD file name length
				mm = zip.charCodeAt(q+30) + 0x100*zip.charCodeAt(q+31);   // mimeCD extra field length
				tt = zip.charCodeAt(q+32) + 0x100*zip.charCodeAt(q+33);   // mimeCD file comment length
				t = q + 46 + nn + mm + tt;                                // t :: GoodCDEntry offset
				if( zip.slice(t,t+4) !== '\x50\x4B\x01\x02' ) throw "Central File Header signature not found."
				nn = zip.charCodeAt(t+28) + 0x100*zip.charCodeAt(t+29);   // goodCD file name length
				mm = zip.charCodeAt(t+30) + 0x100*zip.charCodeAt(t+31);   // goodCD extra field length
				tt = zip.charCodeAt(t+32) + 0x100*zip.charCodeAt(t+33);   // goodCD file comment length
				d = t + 46 + nn + mm + tt;                                // d :: EOCD offset
				if( zip.slice(d,d+4) !== '\x50\x4B\x05\x06' ) throw "End Of Central Directory signature not found."

				// Cur   Desc             Action   Final Offset
				// ----------------------------------------------
				// 0     MimeFileHeader   REMOVE   ~
				// ~     MimeFileData     REMOVE   ~
				// ---
				// p     GoodFileHeader   KEEP     0
				//       GoodFileData     KEEP
				// ---
				// q     MimeCDEntry      REMOVE   ~
				// t     GoodCDEntry      UPDATE   q-p
				// ---
				// d     EOCD             UPDATE

				if( iniUtf8.length===nn )
				{
					// Restore UTF8 filename

					flg = 0x800|(zip.charCodeAt(p+6) + 0x100*zip.charCodeAt(p+7)); // Set bit 11 (UTF8) in general purpose bit flag (bytes 6-7)
					fhd = zip.slice(p,p+6) + U16(flg) + zip.slice(p+8, p+30) + iniUtf8 + zip.slice(p+30+nn, q);  // extra field + data

					flg = 0x800|(zip.charCodeAt(t+8) + 0x100*zip.charCodeAt(t+9)); // Set bit 11 (UTF8) in general purpose bit flag (bytes 6-7)
					cde = zip.slice(t, t+8) + U16(flg) + zip.slice(t+10, t+46) + iniUtf8 + zip.slice(t+46+nn, d);  // extra field + comment
				}
				else
				{
					fhd = zip.slice(p, q);
					cde = zip.slice(t, d);
				}

				cde = cde.slice(0,42) + '\0\0\0\0' + cde.slice(46);       // Update GoodCDEntry's relative offset to 0 (uint32).

				z = zip.charCodeAt(d+12) + 0x100*zip.charCodeAt(d+13)     // Current size of central directory
				  + 0x10000*zip.charCodeAt(d+14)
				  + 0x1000000*zip.charCodeAt(d+15);

				z -= (t-q);                                               // z :: Final size after removing [q,t]
				t = q-p;                                                  // t :: Final start of CD

				eoc = zip.slice(d,d+8)
				    + '\x01\x00\x01\x00'                                  // Change total CD entries ( 2->1 )
				    + U32(z)                                              // New size of the CD (uint32)
				    + U32(t)                                              // New offset of the CD (uint32)
				    + zip.slice(d+20);
			}
			catch(e)
			{
				callee.EMSG = ''+e;
				$$.warn( __("%1 > [APZP] %2", callee.µ, callee.EMSG) );
				return false;
			}

			T&&T( __("%1 > [APZP] Returning the full ZIP stream.", callee.µ) );
			return fhd + cde + eoc;
		}
		.setup
		({
			EMSG: '',
		}),

	})

	//==========================================================================
	// API   All compressors support `input` as
	//       - a JS string (assumed to deliver int8 char codes),
	//       - an array of bytes,
	//       - a (binary) File.
	//==========================================================================

	[PUBLIC]

	({
		// Experimental flag: Setting `µ.ForceInternal` to 1
		// entirely bypasses the (fast) `app.packageUCF` method.
		// (Useful for testing, or in pure estk env.)
		// ---
		ForceInternal: !$$.Env.idVersion(6), // exclude estk

		raw: function raw_SA$File$_S(/*str|byte[]|File*/input,  I,src,sz,bin)
		//----------------------------------
		// Raw DEFLATE Compressor
		// Return the compressed string (byte charcodes) from this input.
		// ---
		// => str [OK]  |  ERR [KO]
		{
			const APT = callee.APZP_THRS; // APZP threshold (~2K)

			I = callee.µ['~'];

			if( !callee.µ.ForceInternal )
			{
				src = I.SRCE(input, APT);                            // src :: str(<=APT) | File(>APT) | false
				false===src && error( __("%1 cannot raw-deflate: %2",callee.µ,I.SRCE.EMSG), callee ); // source error

				sz = src.length;
				bin = (sz > APT) && I.APZP( src, 'only-deflate' );   // bin :: false | str (tried APZP if size > APT)

				// ---
				// [REM] Ignore APZP.EMSG in 'raw' since we'll try internal method.
				// ---

				(src instanceof File) && I.SRCE.CLEAN_TMP(src);      // Cleanup src *if temp file*

				if( bin.length ) return bin;
			}
			else
			{
				input = I.SRCE(input, 1/0);                          // input :: str | false
				false===input && error( __("%1 cannot raw-deflate: %2",callee.µ,I.SRCE.EMSG), callee ); // source error
				sz = input.length;
			}

			// ---
			// If APZP didn't not work, run RCMP iff supported size.
			// ---

			// Precheck size.
			sz > I.MAX_TO_DEFL && error( __("%1 cannot raw-deflate (input size: %2).",callee.µ,sz), callee ); // source too large for RCMP

			src = 'string' == typeof input ? input : I.SRCE(input,1/0); // Forced string (cannot fail)
			bin = I.RCMP(src); // str | false
			false===bin && error( __("%1 cannot raw-deflate: %2",callee.µ,I.RCMP.EMSG), callee ); // DEFLATE error

			return bin;
		}
		.setup
		({
			APZP_THRS: 0x800, // (2K) Beyond this size, prefer APZP if available.
		}),

		zip: function zip_SA$File$_S$File$(/*str|byte[]|File*/input,  I,zip,src,sz,fn,t)
		//----------------------------------
		// ZIP Compressor:
		// - If input is supplied as a string or array of bytes, return
		//   the zipped STRING (byte charcodes).
		// - If input is supplied as a File, create and return the
		//   zipped FILE `<inputName>.zip` at the same location.
		//   (A fresh filename is generated in case of existing file.)
		// If you need to get a ZIP *string* from a File,
		// simply send `$$.File.readBinary(myInputFile)`.
		// ---
		// => str|File [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];

			zip = (!callee.µ.ForceInternal) && I.APZP(input);  // zip :: false | str  (trying the fastest method)

			// ---
			// [REM] APZP.EMSG may return a message.
			// ---

			if( !zip.length ) // Fallback (slower: use RCMP).
			{
				src = 'string' == typeof input ? input : I.SRCE(input,1/0); // Forced string.
				false===src && error( __("%1 cannot zip this input: %2",callee.µ,I.SRCE.EMSG), callee ); // source error

				// Precheck size.
				if( I.MAX_TO_DEFL < (sz=src.length) )
				{
					// Source too large for RCMP:
					// throw APZP error message if available.
					t = I.APZP.EMSG || __("Size too large: %1.", sz);
					error( __("%1 cannot zip this input: %2",callee.µ,t), callee );
				}

				fn = input instanceof File  // ZIP requires a filename:
				? input.getDisplayName()    // Keep original
				: I.DUMMY_NAME;             // Use the temp 'dummy' name

				false === (t=I.RCMP(src)) && error( __("%1 cannot zip this input: %2",callee.µ,I.RCMP.EMSG), callee );
				zip = I.PKWP( src.length, I.CRC32(src), t, fn );
			}

			if( input instanceof File ) // input File implies output File
			{
				fn = input.parent + '/' + input.name.replace(callee.RE_EXT,'') + '.zip';
				t = (new File(fn)).fresh();
				zip = $$.File.writeBinary( t, zip );
				zip || error( __("%1 cannot create the output .zip file %2.",callee.µ,''+t), callee );
			}

			return zip;
		}
		.setup
		({
			RE_EXT: /\.[^.]+$/,
		}),

		gzip: function gzip_SA$File$_S(/*str|byte[]|File*/input,  I,src)
		//----------------------------------
		// GZIP Compressor: return the optimal gzip string (byte charcodes).
		// => str [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];
			src = I.SRCE(input,1/0); // Forced string.
			false===src && error( __("%1 cannot gzip this input: %2",callee.µ,I.SRCE.EMSG), callee ); // source error
			return I.GZWP( src, callee.µ.raw(src) );
		},

		zlib: function zlib_SA$File$_S(/*str|byte[]|File*/input,  I,src)
		//----------------------------------
		// ZLIB Compressor: return the optimal zlib string (byte charcodes).
		// => str [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];
			src = I.SRCE(input,1/0); // Forced string.
			false===src && error( __("%1 cannot zlib this input: %2",callee.µ,I.SRCE.EMSG), callee ); // source error
			return I.ZLWP( src, callee.µ.raw(src) );
		},

	})
