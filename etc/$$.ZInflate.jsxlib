/*******************************************************************************

		Name:           ZInflate
		Desc:           DEFLATE/ZIP/GZIP/ZLIB Decompressors (CM=8)
		Path:           /etc/$$.ZInflate.jsxlib
		Require:        ---
		Encoding:       ÛȚF8
		Core:           NO
		Kind:           Module.
		API:            =unCompress() unRaw() unZip() unGzip() unZlib()
		                ForceInternal
		DOM-access:     app.unpackageUCF() [sometimes used]
		Todo:           ---
		Created:        180921 (YYMMDD)
		Modified:       260205 (YYMMDD)

*******************************************************************************/

#include 'ZDeflateInflate/$$.BitReader.jsxlib'

;$$.hasOwnProperty('ZInflate') || eval(__(MODULE, $$, 'ZInflate', 260205, 'unCompress'))

	//==========================================================================
	// NOTICE
	//==========================================================================

	/*
		[CHG260205] Refactored from scratch.

		The ZInflate module offers all symmetric decompressors to ZDeflate:
		it can decompress ZIP files, GZIP/ZLIB wrappers, and of course
		the pure “DEFLATE” stream as such. It is therefore assumed that any
		input format you may send to this module does 'wrap' a byte stream
		coming from a DEFLATE compression (CM=8 in all specifications).
		
		¹ The raw decompression mechanism is sometimes referred to as
		  ‘inflate’.

		[REM] Whatever the decompression method you invoke, keep in mind
		that the returned string is equivalent to an array of bytes (uint8)
		without extra conversion -- its origin and/or format being unknown.
		So, if the result is to be interpreted as e.g. UTF8 units, it is the
		responsibility of the client script to apply further treatment like
		UTF8->UTF16 conversion via `String.fromUTF8(result)`, and so on.

		ZInflate implements an ExtendScript-optimized inflate algorithm
		(Huffman decoding, support of static/dynamic/stored block types)
		which still offers very acceptable time performance for 200KB or
		more. However, a much faster routine² is used whenever possible
		specifically for ZIP and GZIP streams.

		² InDesign's app.unpackageUCF() directly supports ZIP files.
		  With a simple 'zip-repacking' trick, the same path can be
		  used for GZIP too.

		ZInflate falls back to its internal decompressor (~.INFL) if no faster
		approach is available. Also, you can set the `ForceInternal` property
		to 1 if you want to forcibly disable the 'external' unpackageUCF tool
		and go with the slower, internal implementation.

		[REM] Unlike TinyInflate (recently removed) the present module does
		not support base64 encoding for the input stream. When needed, the
		client code will just have to send `String.fromBase64(myBase64)`
		to obtain the very same functionality.
	*/

	//==========================================================================
	// COMMON ZInflate/ZDeflate TOOLS
	//==========================================================================

	#include 'ZDeflateInflate/$$.common.jsxinc'

	//==========================================================================
	// STATIC H-MAPS (REVERSED)
	//==========================================================================
	
	[PRIVATE]
	
	({
		// REVERSED Static LITERAL/LENGTH Map :: <7|8|9><invStr> => 0..287
		// - 1st charcode of the key: nb of bits
		// - next chars of the key: *reversed* code length [speed up]
		// - result: LL symb
		// Algo for BitReader: 1. read 7 bits -> bin
		//                     2. if the key `<7>bin` exists -> done
		//                     3. read one more bit b -> bin := b+ bin (str)
		//                     4. if the key `<8>bin` exists -> done
		//                     5. read one more bit b -> bin := b+bin (str)
		//                     6. if the key `<9>bin` exists -> done
		//                     7. error
		//----------------------------------
		LLRV:
		{
			"\x0800001100": 0, "\x0810001100": 1, "\x0801001100": 2, "\x0811001100": 3, "\x0800101100": 4, "\x0810101100": 5, "\x0801101100": 6, "\x0811101100": 7,
			"\x0800011100": 8, "\x0810011100": 9, "\x0801011100":10, "\x0811011100":11, "\x0800111100":12, "\x0810111100":13, "\x0801111100":14, "\x0811111100":15,
			"\x0800000010":16, "\x0810000010":17, "\x0801000010":18, "\x0811000010":19, "\x0800100010":20, "\x0810100010":21, "\x0801100010":22, "\x0811100010":23,
			"\x0800010010":24, "\x0810010010":25, "\x0801010010":26, "\x0811010010":27, "\x0800110010":28, "\x0810110010":29, "\x0801110010":30, "\x0811110010":31,
			"\x0800001010":32, "\x0810001010":33, "\x0801001010":34, "\x0811001010":35, "\x0800101010":36, "\x0810101010":37, "\x0801101010":38, "\x0811101010":39,
			"\x0800011010":40, "\x0810011010":41, "\x0801011010":42, "\x0811011010":43, "\x0800111010":44, "\x0810111010":45, "\x0801111010":46, "\x0811111010":47,
			"\x0800000110":48, "\x0810000110":49, "\x0801000110":50, "\x0811000110":51, "\x0800100110":52, "\x0810100110":53, "\x0801100110":54, "\x0811100110":55,
			"\x0800010110":56, "\x0810010110":57, "\x0801010110":58, "\x0811010110":59, "\x0800110110":60, "\x0810110110":61, "\x0801110110":62, "\x0811110110":63,
			"\x0800001110":64, "\x0810001110":65, "\x0801001110":66, "\x0811001110":67, "\x0800101110":68, "\x0810101110":69, "\x0801101110":70, "\x0811101110":71,
			"\x0800011110":72, "\x0810011110":73, "\x0801011110":74, "\x0811011110":75, "\x0800111110":76, "\x0810111110":77, "\x0801111110":78, "\x0811111110":79,
			"\x0800000001":80, "\x0810000001":81, "\x0801000001":82, "\x0811000001":83, "\x0800100001":84, "\x0810100001":85, "\x0801100001":86, "\x0811100001":87,
			"\x0800010001":88, "\x0810010001":89, "\x0801010001":90, "\x0811010001":91, "\x0800110001":92, "\x0810110001":93, "\x0801110001":94, "\x0811110001":95,
			"\x0800001001":96, "\x0810001001":97, "\x0801001001":98, "\x0811001001":99, "\x0800101001":100,"\x0810101001":101,"\x0801101001":102,"\x0811101001":103,
			"\x0800011001":104,"\x0810011001":105,"\x0801011001":106,"\x0811011001":107,"\x0800111001":108,"\x0810111001":109,"\x0801111001":110,"\x0811111001":111,
			"\x0800000101":112,"\x0810000101":113,"\x0801000101":114,"\x0811000101":115,"\x0800100101":116,"\x0810100101":117,"\x0801100101":118,"\x0811100101":119,
			"\x0800010101":120,"\x0810010101":121,"\x0801010101":122,"\x0811010101":123,"\x0800110101":124,"\x0810110101":125,"\x0801110101":126,"\x0811110101":127,
			"\x0800001101":128,"\x0810001101":129,"\x0801001101":130,"\x0811001101":131,"\x0800101101":132,"\x0810101101":133,"\x0801101101":134,"\x0811101101":135,
			"\x0800011101":136,"\x0810011101":137,"\x0801011101":138,"\x0811011101":139,"\x0800111101":140,"\x0810111101":141,"\x0801111101":142,"\x0811111101":143,
			// ---
			"\x09000010011":144,"\x09100010011":145,"\x09010010011":146,"\x09110010011":147,"\x09001010011":148,"\x09101010011":149,"\x09011010011":150,"\x09111010011":151,
			"\x09000110011":152,"\x09100110011":153,"\x09010110011":154,"\x09110110011":155,"\x09001110011":156,"\x09101110011":157,"\x09011110011":158,"\x09111110011":159,
			"\x09000001011":160,"\x09100001011":161,"\x09010001011":162,"\x09110001011":163,"\x09001001011":164,"\x09101001011":165,"\x09011001011":166,"\x09111001011":167,
			"\x09000101011":168,"\x09100101011":169,"\x09010101011":170,"\x09110101011":171,"\x09001101011":172,"\x09101101011":173,"\x09011101011":174,"\x09111101011":175,
			"\x09000011011":176,"\x09100011011":177,"\x09010011011":178,"\x09110011011":179,"\x09001011011":180,"\x09101011011":181,"\x09011011011":182,"\x09111011011":183,
			"\x09000111011":184,"\x09100111011":185,"\x09010111011":186,"\x09110111011":187,"\x09001111011":188,"\x09101111011":189,"\x09011111011":190,"\x09111111011":191,
			"\x09000000111":192,"\x09100000111":193,"\x09010000111":194,"\x09110000111":195,"\x09001000111":196,"\x09101000111":197,"\x09011000111":198,"\x09111000111":199,
			"\x09000100111":200,"\x09100100111":201,"\x09010100111":202,"\x09110100111":203,"\x09001100111":204,"\x09101100111":205,"\x09011100111":206,"\x09111100111":207,
			"\x09000010111":208,"\x09100010111":209,"\x09010010111":210,"\x09110010111":211,"\x09001010111":212,"\x09101010111":213,"\x09011010111":214,"\x09111010111":215,
			"\x09000110111":216,"\x09100110111":217,"\x09010110111":218,"\x09110110111":219,"\x09001110111":220,"\x09101110111":221,"\x09011110111":222,"\x09111110111":223,
			"\x09000001111":224,"\x09100001111":225,"\x09010001111":226,"\x09110001111":227,"\x09001001111":228,"\x09101001111":229,"\x09011001111":230,"\x09111001111":231,
			"\x09000101111":232,"\x09100101111":233,"\x09010101111":234,"\x09110101111":235,"\x09001101111":236,"\x09101101111":237,"\x09011101111":238,"\x09111101111":239,
			"\x09000011111":240,"\x09100011111":241,"\x09010011111":242,"\x09110011111":243,"\x09001011111":244,"\x09101011111":245,"\x09011011111":246,"\x09111011111":247,
			"\x09000111111":248,"\x09100111111":249,"\x09010111111":250,"\x09110111111":251,"\x09001111111":252,"\x09101111111":253,"\x09011111111":254,"\x09111111111":255,
			// ---
			"\x070000000":256,"\x071000000":257,"\x070100000":258,"\x071100000":259,"\x070010000":260,"\x071010000":261,"\x070110000":262,"\x071110000":263,
			"\x070001000":264,"\x071001000":265,"\x070101000":266,"\x071101000":267,"\x070011000":268,"\x071011000":269,"\x070111000":270,"\x071111000":271,
			"\x070000100":272,"\x071000100":273,"\x070100100":274,"\x071100100":275,"\x070010100":276,"\x071010100":277,"\x070110100":278,"\x071110100":279,
			// ---
			"\x0800000011":280,"\x0810000011":281,"\x0801000011":282,"\x0811000011":283,"\x0800100011":284,"\x0810100011":285,"\x0801100011":286,"\x0811100011":287,
		}
		.setup
		({
			MIN_BITS: 7,
			MAX_BITS: 9,
		}),
		
		// REVERSED Static DISTANCE Map :: <5><invStr> => 0..29
		// - 1st charcode of the key: 5
		// - next chars of the key: *reversed* code length [speed up]
		// - result: DS symb
		DSRV:
		{
			"\x0500000" : 0, "\x0510000" : 1, "\x0501000" : 2, "\x0511000" : 3, "\x0500100" : 4, "\x0510100" : 5, "\x0501100" : 6, "\x0511100" : 7,
			"\x0500010" : 8, "\x0510010" : 9, "\x0501010": 10, "\x0511010": 11, "\x0500110": 12, "\x0510110": 13, "\x0501110": 14, "\x0511110": 15,
			"\x0500001": 16, "\x0510001": 17, "\x0501001": 18, "\x0511001": 19, "\x0500101": 20, "\x0510101": 21, "\x0501101": 22, "\x0511101": 23,
			"\x0500011": 24, "\x0510011": 25, "\x0501011": 26, "\x0511011": 27, "\x0500111": 28, "\x0510111": 29,
		}
		.setup
		({
			MIN_BITS: 5,
			MAX_BITS: 5,
		}),

	})

	//==========================================================================
	// (RAW) INFLATE
	//==========================================================================

	[PRIVATE]
	
	({
		SYMB: function(/*BitReader&*/BR,/*{ <n><revbin> => symb ; .MIN_BITS .MAX_BITS }*/rvMap,  mx,bin,nb,k)
		//----------------------------------
		// Return the next rvMap-related symbol.
		// => uint [OK]  |  false [KO]
		{
			const CHR = String.fromCharCode;
			for
			(
				mx=rvMap.MAX_BITS, bin = BR.readBits(nb=rvMap.MIN_BITS,1) ;
				(!rvMap.hasOwnProperty(k=CHR(nb)+bin)) && nb <= mx ;
				(bin=BR.readBits(1,1)+bin), ++nb
			);
			return nb <= mx && rvMap[k];
		},

		DDYN: function(/*BitReader&*/BR,  HLIT,HDIS,CL,rev,hTot,i,z,n,sb,pv)
		//----------------------------------
		// (Decode-Dyn-Trees.) Decode dynamic trees from the stream.
		// this :: ~
		// => { llRev, dsRev }
		{
			HLIT = 257 + BR.readBits(5);                                   // Get 5 bits HLIT  :: 257..286
			HDIS = 1 + BR.readBits(5);                                     // Get 5 bits HDIST :: 1..32

			const ord = this.CL_ORDER;
			CL = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];                  // Init freqs for the 19 CL symbols (0..18)
			z =  4 + BR.readBits(4);                                       // z :: 4..19  (4+HCLEN)
			for( i=-1 ; ++i < z ; CL[ord.charCodeAt(i)]=BR.readBits(3) );  // Read canonical code lengths in 0..7.
			rev = this.HMAP(CL,'REVERSED');                                // rev :: <bits>bin_rev => CL symb

			// Decode code lengths for the dynamic trees.
			// ---
			for( hTot=HLIT+HDIS, n=0 ; n < hTot ; )
			{
				if( 15 >= (sb=this.SYMB(BR,rev)) )
				{
					// Values 0-15 represent the actual code lengths.
					CL[n++] = sb;
					continue;
				}
				if( 16 == sb )
				{
					// Copy previous code length 3-6 times (2 bits)
					for( pv=CL[n-1], z=3+BR.readBits(2) ; z-- ; CL[n++]=pv );
					continue;
				}
				// 17 -> Repeat code length 0 for 3-10 times (3 bits)
				// 18 -> Repeat code length 0 for 11-138 times (7 bits)
				z = 17==sb ? (3+BR.readBits(3)) : (11+BR.readBits(7));
				while( 0 < z-- ) CL[n++]=0;
			}

			return {
				llRev:this.HMAP(CL.slice(0,HLIT),'REVERSED'),
				dsRev:this.HMAP(CL.slice(HLIT,HLIT+HDIS),'REVERSED')
				};
		},

		INFL: function(/*str*/src,  BR,eob,tpe,llRev,dsRev,sb,len,dis,n,p,i,s,t,ret)
		//----------------------------------
		// (Raw-Inflate-Decompressor.) Inflate (i.e uncompress) stream from `src`.
		// this :: ~
		// => str [OK]  |  false [KO] + .EMSG
		{
			const CHR = String.fromCharCode;

			const LSB = this.LS2B;   // LSym  -> Base   (str) ; use LSym - 257
			const LSX = this.LS2X;   // LSym  -> Xbits  (str) ; use LSym - 257
			const DSB = this.DS2B;   // DSym  -> Base   (str)
			const DSX = this.DS2X;   // DSym  -> Xbits  (str)
			
			callee.EMSG = '';

			if( this.MAX_TO_INFL < src.length )
			{
				callee.EMSG = __("The source stream (%1 KB) exceeds the maximum capacity %2 KB.", (src.length/1024).toFixed(1), this.MAX_TO_INFL/1024);
				return false;
			}

			try
			{
				BR = $.global[callee.µ.__root__].BitReader(src);
				for( ret='', eob=0 ; !eob ; )
				{
					eob = BR.readBits(1);        // Read final block flag.
					tpe = BR.readBits(2);        // Read block type (0|1|2).
					if( 2 < tpe ) throw "Invalid block type in the compressed stream.";

					if( 0===tpe )
					{
						// Unprocessed bytes.
						i = BR.idx - BR.byteAlign();
						s = BR.bytes.slice(i);
						// ---
						n = 256*s.charCodeAt(1) + s.charCodeAt(0);
						t = 256*s.charCodeAt(3) + s.charCodeAt(2);
						if( n !== (~t&0xFFFF) ) throw __("Invalid length in stored block: n=%1 t=%2", n,t);
						// ---
						ret += s.slice(4,4+n);
						BR.reset( s.slice(4+n) );
						continue;
					}
					
					2===tpe
					? ( t=this.DDYN(BR), llRev=t.llRev, dsRev=t.dsRev )
					: ( llRev=this.LLRV, dsRev = this.DSRV );

					while( 1 )
					{
						if( false===(sb=this.SYMB(BR,llRev)) ) throw "Invalid LL symbol encoding in the compressed stream.";

						if( 256 >= sb )
						{
							if( 256 == sb ) break; // End of block
							ret += CHR(sb);
							continue;
						}

						sb -= 257;
						len = LSB.charCodeAt(sb) + BR.readBits(LSX.charCodeAt(sb));

						if( false===(sb=this.SYMB(BR,dsRev)) ) throw "Invalid DS symbol encoding in the compressed stream.";
						dis = DSB.charCodeAt(sb) + BR.readBits(DSX.charCodeAt(sb));

						// Copy the match -> ret
						p = (n=ret.length)-dis; // Start index
						if( 0 > p ) throw "Invalid distance in the compressed stream.";
						if( p+len < n )
							ret += ret.substr(p,len);
						else
							for( i=p, p+=len ; i < p ; ret += ret.slice(i,++i) );
					}
				}
			}
			catch(e)
			{
				callee.EMSG = ''+e;
				ret = false;
			}

			return ret;
		}
		.setup
		({
			EMSG: '',
		}),
	})

	//==========================================================================
	// GZIP ZLIB EXTRACTORS
	//==========================================================================

	[PRIVATE]
	
	({

		GZEX: function(/*str*/gzip,  $$,T,n,cm,flg,xlen,p,cz,uz,crc32,ret)
		//----------------------------------
		// (GZIP-Extractor.) Parse a `gzip` stream and return the compressed
		// (DEFLATE) stream with additional information. Extract the DEFLATE
		// data when CM=8 and recover uncompressed size.
		// [REM] ISIZE is modulo 2^32, so files >= 4GB cannot be handled reliably.
		// Anyway, this routine excludes large streams (>32MB) for performance.
		// this :: ~
		// => { comp:str, compSize:uint, unSize:uint, crc32:uint } [OK]
		// |  false [ERR] + .EMSG
		{
			$$ = $.global[callee.µ.__root__]; // agnostic reference
			T = (+$$.trace) && $$.trace;
			T&&T( __("%1 > [GZEX] Want to extract data from a gzip.", callee.µ) );

			callee.EMSG = '';

			// GZIP Member Format (from RFC 1952)
			// Offset  Size  Field
			// ------------------------------------------------------
			// 0       1     ID1 (0x1f)
			// 1       1     ID2 (0x8b)
			// 2       1     CM (Compression Method, 8=deflate)
			// 3       1     FLG (flags)
			// 4       4     MTIME
			// 8       1     XFL
			// 9       1     OS
			// 10      ...   Optional fields based on FLG
			// ...     ...   Compressed blocks
			// -8      4     CRC32
			// -4      4     ISIZE (uncompressed size mod 2^32)
			// ------------------------------------------------------

			// Checkpoints
			// ---
			try
			{
				// Check length and magic bytes
				if( 18 > (n=gzip.length) ) throw "GZIP stream too short!";
				if( n > callee.MAX_INPUT_SIZE ) throw "GZIP stream too large!";
				if( this.GZIN !== gzip.slice(0,this.GZIN.length) )
					throw __("GZIP header signature not found. Expected 0x%1, found 0x%2."
						, (256*this.GZIN.charCodeAt(0)+this.GZIN.charCodeAt(1)).toHexa("", 4)
						, (256*gzip.charCodeAt(0)+gzip.charCodeAt(1)).toHexa("", 4)
						);
				
				// Check compression method
				cm = gzip.charCodeAt(2);
				if( 8 != cm ) throw __("CM method should be 8. Found %1!", cm);

				// Get flags and check reserved bits.
				flg = gzip.charCodeAt(3);
				if( 0xE0&flg ) throw __("Reserved FLG bits are non-zero: %1", flg.toHexa("", 2));

				// Start after fixed header (10 bytes)
				p = 10;

				// Skip FEXTRA if present
				if( 4&flg )
				{
					if( p + 2 > n ) throw "Truncated FEXTRA field!";
					xlen = gzip.charCodeAt(p) + 0x100*gzip.charCodeAt(p+1);
					p += 2 + xlen;
				}

				// Skip FNAME if present (zero-terminated string)
				if( 8&flg )
				{
					for( ; p < n && 0!==gzip.charCodeAt(p) ; ++p );
					if( p >= n ) throw "Truncated FNAME field!";
					++p; // skip zero terminator
				}

				// Skip FCOMMENT if present (zero-terminated string)
				if( 16&flg )
				{
					for( ; p < n && 0!==gzip.charCodeAt(p) ; ++p );
					if( p >= n ) throw "Truncated FCOMMENT field!";
					++p; // skip zero terminator
				}

				// Skip FHCRC if present (2 bytes)
				if( 2&flg ) p += 2;

				// Check we have at least 8 bytes for trailer
				if( p + 8 > n ) throw "GZIP stream truncated!";

				// Compressed size = total - header - trailer(8)
				cz = n - p - 8;
				if( cz < 0 ) throw "Invalid compressed data size!";

				// ISIZE is in last 4 bytes (little-endian, modulo 2^32)
				uz = gzip.charCodeAt(n-4)
				   + 0x100*gzip.charCodeAt(n-3)
				   + 0x10000*gzip.charCodeAt(n-2)
				   + 0x1000000*gzip.charCodeAt(n-1);
				
				// CRC32 is in the 4 bytes before ISIZE (last 8 bytes)
				crc32 = gzip.charCodeAt(n-8)
				   + 0x100*gzip.charCodeAt(n-7)
				   + 0x10000*gzip.charCodeAt(n-6)
				   + 0x1000000*gzip.charCodeAt(n-5);
			}
			catch(e)
			{
				callee.EMSG = ''+e;
				$$.warn( __("%1 > [GZEX] %2", callee.µ, callee.EMSG) );
				return false;
			}
			
			// Return object with extracted info
			ret =
			{
				compSize:   cz,
				unSize:     uz,
				crc32:      crc32,
			};

			T&&T( __("%1 > [GZEX] Returning the DEFLATE stream with extra info %2.", callee.µ, $$.JSON(ret)) );
			
			ret.comp = gzip.slice(p, p+cz);
			return ret;
		}
		.setup
		({
			EMSG: '',
			MAX_INPUT_SIZE: 32 * 1024 * 1024, // 32Mo
		}),

		ZLEX: function(/*str*/zlib,  $$,T,n,cmf,flg,dic,p,cz,adl32,t,ret)
		//----------------------------------
		// (ZLIB-Extractor.) Parse a `zlib` stream and return the compressed
		// (DEFLATE) stream with additional information. Extract the DEFLATE
		// data when CM=8 and recover dictionary ID if present.
		// [REM] Since ZLIB does not encode the original uncompressed size,
		// this extraction step will be followed by an internal DEFL (no
		// boost) so compressed streams larger than about 2MB will be rejected.
		// this :: ~
		// => { comp:str, compSize:uint, adler32:uint [, dictId:uint] } [OK]
		// |  false [ERR] + .EMSG
		{
			$$ = $.global[callee.µ.__root__]; // agnostic reference
			T = (+$$.trace) && $$.trace;
			T&&T( __("%1 > [ZLEX] Want to extract data from a zlib stream.", callee.µ) );

			callee.EMSG = '';

			// ZLIB Stream Format (from RFC 1950)
			// Offset  Size  Field
			// ------------------------------------------------------
			// 0       1     CMF (Compression Method and Flags)
			// 1       1     FLG (Flags)
			// 2       4     DICTID (optional, if FDICT set)
			// ...     ...   Compressed data (DEFLATE)
			// -4      4     ADLER32 checksum
			// ------------------------------------------------------

			// Checkpoints
			// ---
			try
			{
				// Check minimum length (CMF + FLG + ADLER32)
				if( 6 > (n=zlib.length) ) throw "ZLIB stream too short!";
				if( n > callee.MAX_INPUT_SIZE ) throw "ZLIB stream too large!"; // Precheck, refined later.

				// CMF byte
				cmf = zlib.charCodeAt(0);
				t = 0xF&cmf;           // bits 0-3: Compression Method
				if( 8 != t ) throw __("CM method should be 8. Found %1!", t);
				t = 0xF&(cmf>>4);   // bits 4-7: Compression Info (win size)
				if( t > 7 ) throw __("CINFO value %1 not allowed (max 7)!", t);

				// FLG byte
				flg = zlib.charCodeAt(1);
				// --- Verify FCHECK: (CMF*256 + FLG) must be multiple of 31
				if( (256*cmf + flg) % 31 )
					throw __("FCHECK validation failed for CMF=0x%1 FLG=0x%2!", cmf.toHexa("",2), flg.toHexa("",2));
				dic = 1&(flg>>5);  // bit 5: Preset dictionary flag

				// Start after CMF and FLG (2 bytes)
				p = 2;

				// Get DICTID if FDICT is set (4 bytes, big-endian)
				if( dic )
				{
					if( p + 4 > n ) throw "Truncated DICTID field!";
					dic = 0x1000000*zlib.charCodeAt(p)
				        + 0x10000*zlib.charCodeAt(p+1)
				        + 0x100*zlib.charCodeAt(p+2)
				        + zlib.charCodeAt(p+3);
					p += 4;
				}
				else
				{
					dic = false;
				}

				// Check we have at least 4 bytes for ADLER32 trailer
				if( p + 4 > n ) throw "ZLIB stream truncated!";

				// Compressed size = total - header - ADLER32(4)
				cz = n - p - 4;
				if( cz < 0 ) throw "Invalid compressed data size!";
				if( cz > this.MAX_TO_INFL ) throw __("ZLIB's DEFLATE stream too large (%1 bytes) for internal decompression!", cz);

				// ADLER32 is in last 4 bytes (big-endian)
				adl32 = 0x1000000*zlib.charCodeAt(n-4)
			            + 0x10000*zlib.charCodeAt(n-3)
			            + 0x100*zlib.charCodeAt(n-2)
			            + zlib.charCodeAt(n-1);
			}
			catch(e)
			{
				callee.EMSG = ''+e;
				$$.warn( __("%1 > [ZLEX] %2", callee.µ, callee.EMSG) );
				return false;
			}
			
			// Return object with extracted info
			ret =
			{
				compSize:   cz,
				adler32:    adl32,
			};

			// Add dictionary ID if present
			if( false !== dic ) ret.dictId = dic;

			T&&T( __("%1 > [ZLEX] Returning the DEFLATE stream with extra info %2.", callee.µ, $$.JSON(ret)) );
			
			ret.comp = zlib.slice(p, p+cz);
			return ret;
		}
		.setup
		({
			EMSG: '',
			MAX_INPUT_SIZE: 2 * 1024*1024, // 2Mo
		}),

	})

	//==========================================================================
	// ZIP EXTRACTOR AND FAST DECOMPRESSOR
	//==========================================================================

	[PRIVATE]
	
	({
		PKEX: function(/*str*/zip,  $$,T,isUtf8,cm,cz,uz,nn,mm,fn,p,ret)
		//----------------------------------
		// (PKZIP-Extractor.) Parse a `zip` stream assumed to address a
		// SINGLE FILE and return the compressed (DEFLATE) stream with
		// additional information.
		// Used for extracting a valid DEFLATE stream when APUP is
		// unavailable. The compressed data will then undergo 'manual
		// inflate' (INFL) if possible.
		// [REM] `ffName` is the desired *display name* (UTF16 string)
		//       so ffName.toUTF8() is always applied.
		// this :: ~
		// => { comp:str, filename:str, compSize:uint, unSize:uint } [OK]
		// |  false [ERR] + .EMSG
		{
			const PKIN = this.PKIN;
			const UTF8_MASK = 0x800;

			$$ = $.global[callee.µ.__root__]; // agnostic reference
			T = (+$$.trace) && $$.trace;
			T&&T( __("%1 > [PKEX] Want to extract data from a zip.", callee.µ) );

			callee.EMSG = '';

			// Offset  Size Field
			// ------------------------------------------------------
			// 0       4     Local file header signature (0x04034b50)³
			// 4       2     Version needed to extract
			// 6       2     General purpose bit flag
			// 8       2     Compression method (0=stored, 8=deflate)
			// 10      2     Last mod file time (Timestamp)
			// 12      2     Last mod file date (Timestamp)
			// 14      4     CRC-32
			// 18      4     Compressed size (k)
			// 22      4     Uncompressed size
			// 26      2     File name length (n)
			// 28      2     Extra field length (m)
			// 30      n     File name
			// 30+n    m     Extra field
			// 30+n+m  k     FILE DATA (compressed or stored)
			// ------------------------------------------------------
			// Total size = 30 + n + m + k bytes

			// Checkpoints
			// ---
			try
			{
				if( !zip.length ) throw "Empty zip!";
				if( zip.slice(0,4) !== PKIN ) throw "PKZIP header signature not found.";
				
				// Is the UTF8 bit set in flags?
				isUtf8 = UTF8_MASK & (zip.charCodeAt(6) + 0x100*zip.charCodeAt(7));

				// CM method (16bits) : we expect cm==8
				cm = zip.charCodeAt(8) + 0x100*zip.charCodeAt(9);
				if( 8 != cm ) throw __("CM method should be 8. Found %1 (%2)!", cm, cm.toHexa("", 4));

				cz = zip.charCodeAt(18) + 0x100*(zip.charCodeAt(19))  // Compressed size
				   + 0x10000*zip.charCodeAt(20)
				   + 0x1000000*zip.charCodeAt(21);

				uz = zip.charCodeAt(22) + 0x100*(zip.charCodeAt(23))  // Uncompressed size
				   + 0x10000*zip.charCodeAt(24)
				   + 0x1000000*zip.charCodeAt(25);

				nn = zip.charCodeAt(26) + 0x100*zip.charCodeAt(27);   // file name length
				mm = zip.charCodeAt(28) + 0x100*zip.charCodeAt(29);   // extra length
				fn = zip.slice(30,30+nn);                             // Get filename (maybe utf8)

				// Start position (30+nn+mm)
				p = 30+nn+mm;                                             // Start of (DEFLATE) data
			}
			catch(e)
			{
				callee.EMSG = ''+e;
				$$.warn( __("%1 > [PKEX] %2", callee.µ, callee.EMSG) );
				return false;
			}
			
			// Warning: use a new Object and add `comp` after $$.trace (!)
			ret =
			{
				filename:   (isUtf8 ? String.fromUTF8 : String)(fn),
				compSize:   cz,
				unSize:     uz,
			};

			T&&T( __("%1 > [PKEX] Returning the DEFLATE stream with extra info %2.", callee.µ, $$.JSON(ret)) );
			
			ret.comp = zip.slice(p,p+cz);
			return ret;
		}
		.setup
		({
			EMSG: '',
		}),

		APUP: function(/*str|byte[]|File*/zip,  $$,T,isTmpZip,ffZip,fdDst,ucf,t,a,z,ff,ret)
		//----------------------------------
		// (App-Unpackage-ZIP.) Unpack a ZIP stream *owning a single file*
		// through `app.unpackageUCF`.
		// Return the decomrpessed stream as a string.
		// ---
		// this :: ~
		// => str [OK]  |  false [ERR] + .EMSG? (only on FATAL error)
		{
			const PKIN = this.PKIN;
			callee.LAST_FNAME = '';

			$$ = $.global[callee.µ.__root__]; // agnostic reference
			T = (+$$.trace) && $$.trace;
			T&&T( __("%1 > [APUP] Want to unzip a %2 (length: %3).", callee.µ, (zip?zip.constructor.name:typeof zip), (zip||0).length) );
			
			callee.EMSG = '';

			// 1. Make sure we have a valid source
			// ---
			isTmpZip = ffZip = 0;
			while( zip===Object(zip) )
			{
				if( zip instanceof File )
				{
					if( !zip.exists )
					{
						callee.EMSG = __("The file %1 doesn't exist.", ''+zip);
						$$.warn( __("%1 > [APUP] %2", callee.µ, callee.EMSG) );
						return false;
					}
					ffZip = zip;
					T&&T( __("%1 > [APUP] Source ZIP file: %2", callee.µ, ffZip.getDisplayName()) );
					break;
				}
				
				if( zip instanceof Array )
				{
					try
					{
						zip = String.fromCharCode.apply(0,zip);
					}
					catch(e)
					{
						(+$$.warn) && $$.warn( __("%1 > [APUP] Cannot create the byte string from array %2", callee.µ,$$.JSON(zip)) );
						zip = false;
					}
					if( false !== zip )
					{
						T&&T( __("%1 > [APUP] Array successfully converted to string.", callee.µ) );
						break;
					}
				}

				callee.EMSG = __("Invalid source argument (%1).",src.constructor.name);
				$$.warn( __("%1 > [APUP] %2", callee.µ, callee.EMSG) );
				return false;
			}
			if( 0===ffZip )
			{
				if( 'string' != typeof zip )
				{
					callee.EMSG = __("Invalid zip argument (%1).",typeof zip);
					return false;
				}
				if( !zip.length )
				{
					callee.EMSG = __("Empty string.");
					return false;
				}

				T&&T( __("%1 > [APUP] Non-empty string available. (A temp ZIP file is required.)", callee.µ) );
				isTmpZip = 1; // want a temp source ZIP File (pending)
			}
			// --- Precheck that the input has a minimal ZIP signature (PKIN)
			t = ffZip ? $$.File.readBinary(ffZip,PKIN.length) : zip.slice(0,PKIN.length);
			if( PKIN !== t )
			{
				$$.warn
				(
					false===t
					? __("%1 > [APUP] Unable to check the signature of the ZIP file %2.", callee.µ, ''+ffZip)
					: __("%1 > [APUP] Invalid `zip` argument (%2): does not start with the ZIP signature %3.", callee.µ, zip.constructor.name, PKIN.toBytes(true))
				);
				
				callee.EMSG = __("Invalid zip signature");
				return false;
			}
			T&&T( __("%1 > [APUP] Valid ZIP signature.", callee.µ) );

			// 2. Create a temp destination folder (in Folder.temp)
			// ---
			for
			(
				t=$$.File.stamp(5) ;                           // e.g "bazbo"
				(fdDst=new Folder(Folder.temp+'/'+t)).exists ; // While existing folder...
				t = '_'+t                                      // ...preprend '_'
			);
			if( !fdDst.create() )
			{
				$$.warn( __("%1 > [APUP] Cannot create temp destination folder %2", callee.µ,''+fdDst) );
				// NO EMSG
				return false;
			}
			T&&T( __("%1 > [APUP] Set temp folder: %2", callee.µ, ''+fdDst) );

			// 3. If needed, create a temp ffZip (from zip string) inside fdDst.
			// ---
			if( isTmpZip )
			{
				ffZip = $$.File.writeBinary(fdDst + '/' + callee.TMP_ZIP_NAME, zip);
				if( !ffZip )
				{
					$$.warn( __("%1 > [APUP] Cannot write temp ZIP binary file.", callee.µ));
					// NO EMSG
					return false;
				}
				T&&T( __("%1 > [APUP] Temp ZIP file (%2) successfully created from the binary stream %3.", callee.µ, ffZip.getDisplayName(), zip.trunc(100).toSource()) );
			}

			// 4. Unpack the zip thru app.unpackageUCF(zipFile,destFolder)
			try
			{
				app.unpackageUCF( ffZip, fdDst );
				ucf = 1;
				T&&T( __("%1 > [APUP] app.unpackageUCF returned successfully.", callee.µ) );
			}
			catch(e)
			{
				ucf = 0;
				$$.warn( __("%1 > [APUP] app.unpackageUCF failed with args (%2,%3) -- %4", callee.µ,''+ffZip,''+fdDst, ''+e) );
			}

			// 5. Remove ffZip if temporary (IMPORTANT!)
			if( isTmpZip )
			{
				try
				{
					ffZip.remove();
					T&&T( __("%1 > [APUP] Removed temp ZIP file.", callee.µ) );
				}
				catch(e){ $$.warn( __("%1 > [APUP] Cannot remove ZIP file -- %2", callee.µ,''+e) ); }
			}

			if( !ucf )
			{
				try{ fdDst.remove(); } catch(_){}
				// NO EMSG
				return false;
			}

			T&&T( __("%1 > [APUP] Retrieving uncompressed data...", callee.µ) );
			
			// 6. Examine fdDst file(s) and assert SINGLE file.
			for
			(
				ff=z=0, a=fdDst.getFiles() ;
				t=a.pop() ;
				t instanceof File && ( ++z, (ff&&ff.remove()), ff=t )
			);
			if( 1===z )
			{
				callee.LAST_FNAME = ff.name;
				( ret=$$.File.readBinary(ff) )
				? T&&T( __("%1 > [APUP] Uncompressed data (first bytes): %2", callee.µ, ret.slice(0,30).toBytes('hexa').join(' ')) )
				: $$.warn( __("%1 > [APUP] Cannot read binary file!", callee.µ) );
			}
			else
			{
				1 < z
				? $$.warn( __("%1 > [APUP] %1 files found in the ZIP. (This function only supports single zipped file.)", callee.µ, z) )
				: $$.warn( __("%1 > [APUP] No file found in the ZIP!", callee.µ) );
			}

			// 7. Cleanup temp folder.
			try
			{
				ff && ff.remove();
				fdDst.remove();
			}
			catch(e){ $$.warn( __("%1 > [APUP] Cannot remove temp folder -- %2", callee.µ,''+e) ); }

			return ret;
		}
		.setup
		({
			EMSG: '',
			LAST_FNAME: '',
			TMP_ZIP_NAME: 'data.zip',
			GET_LAST_NAME: function(  fn)
			//----------------------------------
			// this :: APUP
			{
				fn = this.LAST_FNAME || '';
				this.LAST_FNAME = '';
				return fn;
			},
		}),

	})

	[PUBLIC]

	//==========================================================================
	// API   All decompressors support `input` as
	//       - a JS string (assumed to deliver int8 char codes),
	//       - an array of bytes,
	//       - a (binary) File.
	//==========================================================================

	({
		// Experimental flag: Setting `µ.ForceInternal` to 1
		// entirely bypasses the (fast) `app.unpackageUCF` method
		// in `unzip`. (Useful for testing, or in pure estk env.)
		// ---
		ForceInternal: !$$.Env.idVersion(6), // exclude estk

		unCompress: function unCompress_SA$File$_S(/*str|byte[]|File*/input,  I,ME,src,n,t,out)
		//----------------------------------
		// Agnostic Decompressor: autodetect the wrapper (if any).
		// [REM] Will return a File (as unZip would do) if input
		// is a ZIP stream passed as a File.
		// => str|File [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];
			ME = callee.µ + '.' + callee.name.split('_');

			false===(src=I.SRCE(input,1/0)) // Forced string.
			&& error( __("%1 error. %2",ME,I.SRCE.EMSG), callee ); // source error
			
			try
			{
				// Minimum sizes for each format:
				// ZIP:  30 bytes (local file header minimum)
				// GZIP: 18 bytes (header + trailer minimum)
				// ZLIB: 6 bytes (CMF + FLG + ADLER32 minimum)
				// ---
				n = src.length;

				if( 30 <= n )
				{
					t = I.PKIN; // '\x50\x4B\x03\x04'
					if( t===src.slice(0,t.length) )
					{
						out = callee.µ.unZip(input);    // ZIP format (may error)
						return out;
					}
				}

				if( 18 <= n )
				{
					t = I.GZIN; // '\x1F\x8B'
					if( t===src.slice(0,t.length) )
					{
						out = callee.µ.unGzip(input);   // GZIP format (may error)
						return out;
					}
				}
				
				if( 6 <= n )
				{
					// Try ZLIB format (CMF byte with CM=8 in lower 4 bits: 0x78, 0x58, 0x38, 0x18)
					t = src.charCodeAt(0);
					if( 8 === (0xF&t) && t <= 0x9F )
					{
						out = callee.µ.unZlib(input);   // ZLIB format (may error)
						return out;
					}
				}
			}
			catch(_){}

			// Fallback: assume raw DEFLATE
			return callee.µ.unRaw(input);
		},

		unRaw: function unRaw_SA$File$_S(/*str|byte[]|File*/input,  I,ME,src,out)
		//----------------------------------
		// Raw decompressor. Return the decompressed string (byte charcodes)
		// from a pure DEFLATE input.
		// [REM] This method cannot benefit from the APUP boost, so
		// it does not support large input streams (maximum ~2MB).
		// => str [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];
			ME = callee.µ + '.' + callee.name.split('_')[0];

			false===(src=I.SRCE(input,1/0)) // Forced string.
			&& error( __("%1 error. %2",ME,I.SRCE.EMSG), callee ); // source error

			false===(out=I.INFL(src))
			&& error( __("%1 decompression error. %2",ME,I.INFL.EMSG), callee ); // inflate error
			
			return out;
		},

		unZip: function unZip_SA$File$_S$File$(/*str|byte[]|File*/input,  I,ME,fn,out,zip,t,data)
		//----------------------------------
		// ZIP Decompressor:
		// - As a ZIP archive, input MUST CONTAIN A SINGLE ELEMENT.
		//   Should you need to unzip a multi-element archive, simply
		//   call InDesign DOM's app.unpackageUCF(zipFile,destFolder)
		// - If input is supplied as a string or array of bytes,
		//   return the uncompressed file as a STRING (byte charcodes).
		// - If input is supplied as a File, create and return the
		//   uncompressed FILE at the same location. (A fresh filename
		//   is generated in case of existing file.)
		// - If you need to get a 'unzipped' *string* from a File,
		//   just input `$$.File.readBinary(myInputZipFile)`.
		// => str|File [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];
			ME = callee.µ + '.' + callee.name.split('_')[0];

			fn = '';
			out = (!callee.µ.ForceInternal) && I.APUP(input);  // out :: false | str  (trying the fastest method)

			if( !out.length )                                  // Fallback (slower: use INFL).
			{
				I.APUP.EMSG
				&& error( __("%1 unpackage error. %2",ME,I.APUP.EMSG), callee );

				false===(zip = 'string' == typeof input ? input : I.SRCE(input,1/0)) // Forced string
				&& error( __("%1 error. %2",ME,I.SRCE.EMSG), callee ); // source error

				// data :: false | { comp:str, filename:str, compSize:uint, unSize:uint }
				(data=I.PKEX(zip))
				|| error( __("%1 unwrap error. %2",ME,I.PKEX.EMSG), callee ); // unwrap error
				
				I.MAX_TO_INFL < data.compSize
				&& error( __("%1 cannot inflate %2 bytes: exceeds the limit (%3).",ME,data.compSize,I.MAX_TO_INFL), callee );

				fn = data.filename;
				false===(out=I.INFL(data.comp))
				&& error( __("%1 decompression error. %2",ME,I.INFL.EMSG), callee ); // inflate error
			}
			else
			{
				fn = I.APUP.GET_LAST_NAME();
			}

			if( input instanceof File )                          // input File implies output File
			{
				fn || (fn=input.name.replace(callee.RE_EXT,'') + '.bin');
				fn = input.parent + '/' + fn;
				t = (new File(fn)).fresh();
				out = $$.File.writeBinary( t, out );
				out || error( __("%1 failed to create the output file %2.",ME,''+t), callee );
			}

			return out;
		}
		.setup
		({
			RE_EXT: /\.[^.]+$/,
		}),

		unGzip: function unGzip_SA$File$_S(/*str|byte[]|File*/input,  I,ME,src,data,zip,out)
		//----------------------------------
		// GZIP Decompressor. Given a valid GZIP stream based on CM=8
		// (aka GZIP-wrapped INFLATE data), return the decompressed string
		// (byte charcodes).
		// => str [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];
			ME = callee.µ + '.' + callee.name.split('_')[0];

			false===(src=I.SRCE(input,1/0)) // Forced string.
			&& error( __("%1 error. %2",ME,I.SRCE.EMSG), callee ); // source error

			// 1. Unwrap data.
			(data=I.GZEX(src)) // false | { comp:str, compSize:uint, unSize:uint, crc32:uint }
			|| error( __("%1 unwrap error. %2",ME,I.GZEX.EMSG), callee ); // unwrap error

			// 2. Select the best strategy:
			// - repack as a ZIP and call APUP :-)
			// - or use internal INFLATE :-(
			if( !callee.µ.ForceInternal )
			{
				zip = I.PKWP(data.unSize,data.crc32,data.comp); // Cannot fail (but the zip is unsafe!)
				out = I.APUP(zip);                              // out :: false | str   ; errors have been $$.warned
				if( out.length ) return out;                    // Done!
			}
			
			I.MAX_TO_INFL < data.compSize
			&& error( __("%1 cannot inflate %2 bytes: exceeds the limit (%3).",ME,data.compSize,I.MAX_TO_INFL), callee );

			false===(out=I.INFL(data.comp))
			&& error( __("%1 decompression error. %2",ME,I.INFL.EMSG), callee ); // inflate error

			return out;
		},

		unZlib: function unZlib_SA$File$_S(/*str|byte[]|File*/input,  I,ME,src,data,out)
		//----------------------------------
		// ZLIB Decompressor. Given a valid ZLIB stream based on CM=8
		// (aka ZLIB-wrapped INFLATE data), return the decompressed string
		// (byte charcodes).
		// [REM] This method cannot benefit from the APUP boost, so
		// it does not support large input streams (maximum ~2MB).
		// => str [OK]  |  ERR [KO]
		{
			I = callee.µ['~'];
			ME = callee.µ + '.' + callee.name.split('_')[0];

			false===(src=I.SRCE(input,1/0)) // Forced string.
			&& error( __("%1 error. %2",ME,I.SRCE.EMSG), callee ); // source error

			// Unwrap
			(data=I.ZLEX(src)) // false | { comp:str, compSize:uint, adler32:uint [, dictId:uint] }
			|| error( __("%1 unwrap error. %2",ME,I.ZLEX.EMSG), callee ); // unwrap error

			false===(out=I.INFL(data.comp))
			&& error( __("%1 decompression error. %2",ME,I.INFL.EMSG), callee ); // inflate error

			return out;
		},

	})

